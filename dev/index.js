/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@openmeteo/sdk/aggregation.js":
/*!****************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/aggregation.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Aggregation = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
var Aggregation;
(function (Aggregation) {
    Aggregation[Aggregation["none"] = 0] = "none";
    Aggregation[Aggregation["minimum"] = 1] = "minimum";
    Aggregation[Aggregation["maximum"] = 2] = "maximum";
    Aggregation[Aggregation["mean"] = 3] = "mean";
    Aggregation[Aggregation["p10"] = 4] = "p10";
    Aggregation[Aggregation["p25"] = 5] = "p25";
    Aggregation[Aggregation["median"] = 6] = "median";
    Aggregation[Aggregation["p75"] = 7] = "p75";
    Aggregation[Aggregation["p90"] = 8] = "p90";
    Aggregation[Aggregation["dominant"] = 9] = "dominant";
    Aggregation[Aggregation["sum"] = 10] = "sum";
})(Aggregation || (exports.Aggregation = Aggregation = {}));


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/model.js":
/*!**********************************************!*\
  !*** ./node_modules/@openmeteo/sdk/model.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Model = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
var Model;
(function (Model) {
    Model[Model["undefined"] = 0] = "undefined";
    Model[Model["best_match"] = 1] = "best_match";
    Model[Model["gfs_seamless"] = 2] = "gfs_seamless";
    Model[Model["gfs_global"] = 3] = "gfs_global";
    Model[Model["gfs_hrrr"] = 4] = "gfs_hrrr";
    Model[Model["meteofrance_seamless"] = 5] = "meteofrance_seamless";
    Model[Model["meteofrance_arpege_seamless"] = 6] = "meteofrance_arpege_seamless";
    Model[Model["meteofrance_arpege_world"] = 7] = "meteofrance_arpege_world";
    Model[Model["meteofrance_arpege_europe"] = 8] = "meteofrance_arpege_europe";
    Model[Model["meteofrance_arome_seamless"] = 9] = "meteofrance_arome_seamless";
    Model[Model["meteofrance_arome_france"] = 10] = "meteofrance_arome_france";
    Model[Model["meteofrance_arome_france_hd"] = 11] = "meteofrance_arome_france_hd";
    Model[Model["jma_seamless"] = 12] = "jma_seamless";
    Model[Model["jma_msm"] = 13] = "jma_msm";
    Model[Model["jms_gsm"] = 14] = "jms_gsm";
    Model[Model["jma_gsm"] = 15] = "jma_gsm";
    Model[Model["gem_seamless"] = 16] = "gem_seamless";
    Model[Model["gem_global"] = 17] = "gem_global";
    Model[Model["gem_regional"] = 18] = "gem_regional";
    Model[Model["gem_hrdps_continental"] = 19] = "gem_hrdps_continental";
    Model[Model["icon_seamless"] = 20] = "icon_seamless";
    Model[Model["icon_global"] = 21] = "icon_global";
    Model[Model["icon_eu"] = 22] = "icon_eu";
    Model[Model["icon_d2"] = 23] = "icon_d2";
    Model[Model["ecmwf_ifs04"] = 24] = "ecmwf_ifs04";
    Model[Model["metno_nordic"] = 25] = "metno_nordic";
    Model[Model["era5_seamless"] = 26] = "era5_seamless";
    Model[Model["era5"] = 27] = "era5";
    Model[Model["cerra"] = 28] = "cerra";
    Model[Model["era5_land"] = 29] = "era5_land";
    Model[Model["ecmwf_ifs"] = 30] = "ecmwf_ifs";
    Model[Model["gwam"] = 31] = "gwam";
    Model[Model["ewam"] = 32] = "ewam";
    Model[Model["glofas_seamless_v3"] = 33] = "glofas_seamless_v3";
    Model[Model["glofas_forecast_v3"] = 34] = "glofas_forecast_v3";
    Model[Model["glofas_consolidated_v3"] = 35] = "glofas_consolidated_v3";
    Model[Model["glofas_seamless_v4"] = 36] = "glofas_seamless_v4";
    Model[Model["glofas_forecast_v4"] = 37] = "glofas_forecast_v4";
    Model[Model["glofas_consolidated_v4"] = 38] = "glofas_consolidated_v4";
    Model[Model["gfs025"] = 39] = "gfs025";
    Model[Model["gfs05"] = 40] = "gfs05";
    Model[Model["CMCC_CM2_VHR4"] = 41] = "CMCC_CM2_VHR4";
    Model[Model["FGOALS_f3_H_highresSST"] = 42] = "FGOALS_f3_H_highresSST";
    Model[Model["FGOALS_f3_H"] = 43] = "FGOALS_f3_H";
    Model[Model["HiRAM_SIT_HR"] = 44] = "HiRAM_SIT_HR";
    Model[Model["MRI_AGCM3_2_S"] = 45] = "MRI_AGCM3_2_S";
    Model[Model["EC_Earth3P_HR"] = 46] = "EC_Earth3P_HR";
    Model[Model["MPI_ESM1_2_XR"] = 47] = "MPI_ESM1_2_XR";
    Model[Model["NICAM16_8S"] = 48] = "NICAM16_8S";
    Model[Model["cams_europe"] = 49] = "cams_europe";
    Model[Model["cams_global"] = 50] = "cams_global";
    Model[Model["cfsv2"] = 51] = "cfsv2";
    Model[Model["era5_ocean"] = 52] = "era5_ocean";
    Model[Model["cma_grapes_global"] = 53] = "cma_grapes_global";
    Model[Model["bom_access_global"] = 54] = "bom_access_global";
    Model[Model["bom_access_global_ensemble"] = 55] = "bom_access_global_ensemble";
    Model[Model["arpae_cosmo_seamless"] = 56] = "arpae_cosmo_seamless";
    Model[Model["arpae_cosmo_2i"] = 57] = "arpae_cosmo_2i";
    Model[Model["arpae_cosmo_2i_ruc"] = 58] = "arpae_cosmo_2i_ruc";
    Model[Model["arpae_cosmo_5m"] = 59] = "arpae_cosmo_5m";
    Model[Model["ecmwf_ifs025"] = 60] = "ecmwf_ifs025";
    Model[Model["ecmwf_aifs025"] = 61] = "ecmwf_aifs025";
    Model[Model["gfs013"] = 62] = "gfs013";
    Model[Model["gfs_graphcast025"] = 63] = "gfs_graphcast025";
    Model[Model["ecmwf_wam025"] = 64] = "ecmwf_wam025";
    Model[Model["meteofrance_wave"] = 65] = "meteofrance_wave";
    Model[Model["meteofrance_currents"] = 66] = "meteofrance_currents";
})(Model || (exports.Model = Model = {}));


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/unit.js":
/*!*********************************************!*\
  !*** ./node_modules/@openmeteo/sdk/unit.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unit = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
var Unit;
(function (Unit) {
    Unit[Unit["undefined"] = 0] = "undefined";
    Unit[Unit["celsius"] = 1] = "celsius";
    Unit[Unit["centimetre"] = 2] = "centimetre";
    Unit[Unit["cubic_metre_per_cubic_metre"] = 3] = "cubic_metre_per_cubic_metre";
    Unit[Unit["cubic_metre_per_second"] = 4] = "cubic_metre_per_second";
    Unit[Unit["degree_direction"] = 5] = "degree_direction";
    Unit[Unit["dimensionless_integer"] = 6] = "dimensionless_integer";
    Unit[Unit["dimensionless"] = 7] = "dimensionless";
    Unit[Unit["european_air_quality_index"] = 8] = "european_air_quality_index";
    Unit[Unit["fahrenheit"] = 9] = "fahrenheit";
    Unit[Unit["feet"] = 10] = "feet";
    Unit[Unit["fraction"] = 11] = "fraction";
    Unit[Unit["gdd_celsius"] = 12] = "gdd_celsius";
    Unit[Unit["geopotential_metre"] = 13] = "geopotential_metre";
    Unit[Unit["grains_per_cubic_metre"] = 14] = "grains_per_cubic_metre";
    Unit[Unit["gram_per_kilogram"] = 15] = "gram_per_kilogram";
    Unit[Unit["hectopascal"] = 16] = "hectopascal";
    Unit[Unit["hours"] = 17] = "hours";
    Unit[Unit["inch"] = 18] = "inch";
    Unit[Unit["iso8601"] = 19] = "iso8601";
    Unit[Unit["joule_per_kilogram"] = 20] = "joule_per_kilogram";
    Unit[Unit["kelvin"] = 21] = "kelvin";
    Unit[Unit["kilopascal"] = 22] = "kilopascal";
    Unit[Unit["kilogram_per_square_metre"] = 23] = "kilogram_per_square_metre";
    Unit[Unit["kilometres_per_hour"] = 24] = "kilometres_per_hour";
    Unit[Unit["knots"] = 25] = "knots";
    Unit[Unit["megajoule_per_square_metre"] = 26] = "megajoule_per_square_metre";
    Unit[Unit["metre_per_second_not_unit_converted"] = 27] = "metre_per_second_not_unit_converted";
    Unit[Unit["metre_per_second"] = 28] = "metre_per_second";
    Unit[Unit["metre"] = 29] = "metre";
    Unit[Unit["micrograms_per_cubic_metre"] = 30] = "micrograms_per_cubic_metre";
    Unit[Unit["miles_per_hour"] = 31] = "miles_per_hour";
    Unit[Unit["millimetre"] = 32] = "millimetre";
    Unit[Unit["pascal"] = 33] = "pascal";
    Unit[Unit["per_second"] = 34] = "per_second";
    Unit[Unit["percentage"] = 35] = "percentage";
    Unit[Unit["seconds"] = 36] = "seconds";
    Unit[Unit["unix_time"] = 37] = "unix_time";
    Unit[Unit["us_air_quality_index"] = 38] = "us_air_quality_index";
    Unit[Unit["watt_per_square_metre"] = 39] = "watt_per_square_metre";
    Unit[Unit["wmo_code"] = 40] = "wmo_code";
})(Unit || (exports.Unit = Unit = {}));


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/variable-with-values.js":
/*!*************************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/variable-with-values.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VariableWithValues = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
const flatbuffers = __importStar(__webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/mjs/flatbuffers.js"));
const aggregation_js_1 = __webpack_require__(/*! ./aggregation.js */ "./node_modules/@openmeteo/sdk/aggregation.js");
const unit_js_1 = __webpack_require__(/*! ./unit.js */ "./node_modules/@openmeteo/sdk/unit.js");
const variable_js_1 = __webpack_require__(/*! ./variable.js */ "./node_modules/@openmeteo/sdk/variable.js");
class VariableWithValues {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsVariableWithValues(bb, obj) {
        return (obj || new VariableWithValues()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsVariableWithValues(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new VariableWithValues()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    variable() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : variable_js_1.Variable.undefined;
    }
    unit() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : unit_js_1.Unit.undefined;
    }
    value() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    values(index) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    valuesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    valuesArray() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    valuesInt64(index) {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    valuesInt64Length() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    altitude() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    aggregation() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : aggregation_js_1.Aggregation.none;
    }
    pressureLevel() {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    depth() {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    depthTo() {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    ensembleMember() {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
    previousDay() {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? this.bb.readInt16(this.bb_pos + offset) : 0;
    }
}
exports.VariableWithValues = VariableWithValues;


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/variable.js":
/*!*************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/variable.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Variable = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
var Variable;
(function (Variable) {
    Variable[Variable["undefined"] = 0] = "undefined";
    Variable[Variable["apparent_temperature"] = 1] = "apparent_temperature";
    Variable[Variable["cape"] = 2] = "cape";
    Variable[Variable["cloud_cover"] = 3] = "cloud_cover";
    Variable[Variable["cloud_cover_high"] = 4] = "cloud_cover_high";
    Variable[Variable["cloud_cover_low"] = 5] = "cloud_cover_low";
    Variable[Variable["cloud_cover_mid"] = 6] = "cloud_cover_mid";
    Variable[Variable["daylight_duration"] = 7] = "daylight_duration";
    Variable[Variable["dew_point"] = 8] = "dew_point";
    Variable[Variable["diffuse_radiation"] = 9] = "diffuse_radiation";
    Variable[Variable["diffuse_radiation_instant"] = 10] = "diffuse_radiation_instant";
    Variable[Variable["direct_normal_irradiance"] = 11] = "direct_normal_irradiance";
    Variable[Variable["direct_normal_irradiance_instant"] = 12] = "direct_normal_irradiance_instant";
    Variable[Variable["direct_radiation"] = 13] = "direct_radiation";
    Variable[Variable["direct_radiation_instant"] = 14] = "direct_radiation_instant";
    Variable[Variable["et0_fao_evapotranspiration"] = 15] = "et0_fao_evapotranspiration";
    Variable[Variable["evapotranspiration"] = 16] = "evapotranspiration";
    Variable[Variable["freezing_level_height"] = 17] = "freezing_level_height";
    Variable[Variable["growing_degree_days"] = 18] = "growing_degree_days";
    Variable[Variable["is_day"] = 19] = "is_day";
    Variable[Variable["latent_heat_flux"] = 20] = "latent_heat_flux";
    Variable[Variable["leaf_wetness_probability"] = 21] = "leaf_wetness_probability";
    Variable[Variable["lifted_index"] = 22] = "lifted_index";
    Variable[Variable["lightning_potential"] = 23] = "lightning_potential";
    Variable[Variable["precipitation"] = 24] = "precipitation";
    Variable[Variable["precipitation_hours"] = 25] = "precipitation_hours";
    Variable[Variable["precipitation_probability"] = 26] = "precipitation_probability";
    Variable[Variable["pressure_msl"] = 27] = "pressure_msl";
    Variable[Variable["rain"] = 28] = "rain";
    Variable[Variable["relative_humidity"] = 29] = "relative_humidity";
    Variable[Variable["runoff"] = 30] = "runoff";
    Variable[Variable["sensible_heat_flux"] = 31] = "sensible_heat_flux";
    Variable[Variable["shortwave_radiation"] = 32] = "shortwave_radiation";
    Variable[Variable["shortwave_radiation_instant"] = 33] = "shortwave_radiation_instant";
    Variable[Variable["showers"] = 34] = "showers";
    Variable[Variable["snow_depth"] = 35] = "snow_depth";
    Variable[Variable["snow_height"] = 36] = "snow_height";
    Variable[Variable["snowfall"] = 37] = "snowfall";
    Variable[Variable["snowfall_height"] = 38] = "snowfall_height";
    Variable[Variable["snowfall_water_equivalent"] = 39] = "snowfall_water_equivalent";
    Variable[Variable["sunrise"] = 40] = "sunrise";
    Variable[Variable["sunset"] = 41] = "sunset";
    Variable[Variable["soil_moisture"] = 42] = "soil_moisture";
    Variable[Variable["soil_moisture_index"] = 43] = "soil_moisture_index";
    Variable[Variable["soil_temperature"] = 44] = "soil_temperature";
    Variable[Variable["surface_pressure"] = 45] = "surface_pressure";
    Variable[Variable["surface_temperature"] = 46] = "surface_temperature";
    Variable[Variable["temperature"] = 47] = "temperature";
    Variable[Variable["terrestrial_radiation"] = 48] = "terrestrial_radiation";
    Variable[Variable["terrestrial_radiation_instant"] = 49] = "terrestrial_radiation_instant";
    Variable[Variable["total_column_integrated_water_vapour"] = 50] = "total_column_integrated_water_vapour";
    Variable[Variable["updraft"] = 51] = "updraft";
    Variable[Variable["uv_index"] = 52] = "uv_index";
    Variable[Variable["uv_index_clear_sky"] = 53] = "uv_index_clear_sky";
    Variable[Variable["vapour_pressure_deficit"] = 54] = "vapour_pressure_deficit";
    Variable[Variable["visibility"] = 55] = "visibility";
    Variable[Variable["weather_code"] = 56] = "weather_code";
    Variable[Variable["wind_direction"] = 57] = "wind_direction";
    Variable[Variable["wind_gusts"] = 58] = "wind_gusts";
    Variable[Variable["wind_speed"] = 59] = "wind_speed";
    Variable[Variable["vertical_velocity"] = 60] = "vertical_velocity";
    Variable[Variable["geopotential_height"] = 61] = "geopotential_height";
    Variable[Variable["wet_bulb_temperature"] = 62] = "wet_bulb_temperature";
    Variable[Variable["river_discharge"] = 63] = "river_discharge";
    Variable[Variable["wave_height"] = 64] = "wave_height";
    Variable[Variable["wave_period"] = 65] = "wave_period";
    Variable[Variable["wave_direction"] = 66] = "wave_direction";
    Variable[Variable["wind_wave_height"] = 67] = "wind_wave_height";
    Variable[Variable["wind_wave_period"] = 68] = "wind_wave_period";
    Variable[Variable["wind_wave_peak_period"] = 69] = "wind_wave_peak_period";
    Variable[Variable["wind_wave_direction"] = 70] = "wind_wave_direction";
    Variable[Variable["swell_wave_height"] = 71] = "swell_wave_height";
    Variable[Variable["swell_wave_period"] = 72] = "swell_wave_period";
    Variable[Variable["swell_wave_peak_period"] = 73] = "swell_wave_peak_period";
    Variable[Variable["swell_wave_direction"] = 74] = "swell_wave_direction";
    Variable[Variable["pm10"] = 75] = "pm10";
    Variable[Variable["pm2p5"] = 76] = "pm2p5";
    Variable[Variable["dust"] = 77] = "dust";
    Variable[Variable["aerosol_optical_depth"] = 78] = "aerosol_optical_depth";
    Variable[Variable["carbon_monoxide"] = 79] = "carbon_monoxide";
    Variable[Variable["nitrogen_dioxide"] = 80] = "nitrogen_dioxide";
    Variable[Variable["ammonia"] = 81] = "ammonia";
    Variable[Variable["ozone"] = 82] = "ozone";
    Variable[Variable["sulphur_dioxide"] = 83] = "sulphur_dioxide";
    Variable[Variable["alder_pollen"] = 84] = "alder_pollen";
    Variable[Variable["birch_pollen"] = 85] = "birch_pollen";
    Variable[Variable["grass_pollen"] = 86] = "grass_pollen";
    Variable[Variable["mugwort_pollen"] = 87] = "mugwort_pollen";
    Variable[Variable["olive_pollen"] = 88] = "olive_pollen";
    Variable[Variable["ragweed_pollen"] = 89] = "ragweed_pollen";
    Variable[Variable["european_aqi"] = 90] = "european_aqi";
    Variable[Variable["european_aqi_pm2p5"] = 91] = "european_aqi_pm2p5";
    Variable[Variable["european_aqi_pm10"] = 92] = "european_aqi_pm10";
    Variable[Variable["european_aqi_nitrogen_dioxide"] = 93] = "european_aqi_nitrogen_dioxide";
    Variable[Variable["european_aqi_ozone"] = 94] = "european_aqi_ozone";
    Variable[Variable["european_aqi_sulphur_dioxide"] = 95] = "european_aqi_sulphur_dioxide";
    Variable[Variable["us_aqi"] = 96] = "us_aqi";
    Variable[Variable["us_aqi_pm2p5"] = 97] = "us_aqi_pm2p5";
    Variable[Variable["us_aqi_pm10"] = 98] = "us_aqi_pm10";
    Variable[Variable["us_aqi_nitrogen_dioxide"] = 99] = "us_aqi_nitrogen_dioxide";
    Variable[Variable["us_aqi_ozone"] = 100] = "us_aqi_ozone";
    Variable[Variable["us_aqi_sulphur_dioxide"] = 101] = "us_aqi_sulphur_dioxide";
    Variable[Variable["us_aqi_carbon_monoxide"] = 102] = "us_aqi_carbon_monoxide";
    Variable[Variable["sunshine_duration"] = 103] = "sunshine_duration";
    Variable[Variable["convective_inhibition"] = 104] = "convective_inhibition";
    Variable[Variable["shortwave_radiation_clear_sky"] = 105] = "shortwave_radiation_clear_sky";
    Variable[Variable["global_tilted_irradiance"] = 106] = "global_tilted_irradiance";
    Variable[Variable["global_tilted_irradiance_instant"] = 107] = "global_tilted_irradiance_instant";
    Variable[Variable["ocean_current_velocity"] = 108] = "ocean_current_velocity";
    Variable[Variable["ocean_current_direction"] = 109] = "ocean_current_direction";
})(Variable || (exports.Variable = Variable = {}));


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/variables-with-time.js":
/*!************************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/variables-with-time.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VariablesWithTime = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
const flatbuffers = __importStar(__webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/mjs/flatbuffers.js"));
const variable_with_values_js_1 = __webpack_require__(/*! ./variable-with-values.js */ "./node_modules/@openmeteo/sdk/variable-with-values.js");
class VariablesWithTime {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsVariablesWithTime(bb, obj) {
        return (obj || new VariablesWithTime()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsVariablesWithTime(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new VariablesWithTime()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    time() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    timeEnd() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    interval() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    variables(index, obj) {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new variable_with_values_js_1.VariableWithValues()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    variablesLength() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
}
exports.VariablesWithTime = VariablesWithTime;


/***/ }),

/***/ "./node_modules/@openmeteo/sdk/weather-api-response.js":
/*!*************************************************************!*\
  !*** ./node_modules/@openmeteo/sdk/weather-api-response.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// automatically generated by the FlatBuffers compiler, do not modify
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WeatherApiResponse = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
const flatbuffers = __importStar(__webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/mjs/flatbuffers.js"));
const model_js_1 = __webpack_require__(/*! ./model.js */ "./node_modules/@openmeteo/sdk/model.js");
const variables_with_time_js_1 = __webpack_require__(/*! ./variables-with-time.js */ "./node_modules/@openmeteo/sdk/variables-with-time.js");
class WeatherApiResponse {
    constructor() {
        this.bb = null;
        this.bb_pos = 0;
    }
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsWeatherApiResponse(bb, obj) {
        return (obj || new WeatherApiResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsWeatherApiResponse(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new WeatherApiResponse()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    latitude() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    longitude() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    elevation() {
        const offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    generationTimeMilliseconds() {
        const offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0.0;
    }
    locationId() {
        const offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt('0');
    }
    model() {
        const offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.readUint8(this.bb_pos + offset) : model_js_1.Model.undefined;
    }
    utcOffsetSeconds() {
        const offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    timezone(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 18);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    timezoneAbbreviation(optionalEncoding) {
        const offset = this.bb.__offset(this.bb_pos, 20);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    current(obj) {
        const offset = this.bb.__offset(this.bb_pos, 22);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    daily(obj) {
        const offset = this.bb.__offset(this.bb_pos, 24);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    hourly(obj) {
        const offset = this.bb.__offset(this.bb_pos, 26);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    minutely15(obj) {
        const offset = this.bb.__offset(this.bb_pos, 28);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    sixHourly(obj) {
        const offset = this.bb.__offset(this.bb_pos, 30);
        return offset ? (obj || new variables_with_time_js_1.VariablesWithTime()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
}
exports.WeatherApiResponse = WeatherApiResponse;


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/builder.js":
/*!*************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/builder.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* binding */ Builder)
/* harmony export */ });
/* harmony import */ var _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-buffer.js */ "./node_modules/flatbuffers/mjs/byte-buffer.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants.js */ "./node_modules/flatbuffers/mjs/constants.js");


class Builder {
    /**
     * Create a FlatBufferBuilder.
     */
    constructor(opt_initial_size) {
        /** Minimum alignment encountered so far. */
        this.minalign = 1;
        /** The vtable for the current table. */
        this.vtable = null;
        /** The amount of fields we're actually using. */
        this.vtable_in_use = 0;
        /** Whether we are currently serializing a table. */
        this.isNested = false;
        /** Starting offset of the current struct/table. */
        this.object_start = 0;
        /** List of offsets of all vtables. */
        this.vtables = [];
        /** For the current vector being built. */
        this.vector_num_elems = 0;
        /** False omits default values from the serialized data */
        this.force_defaults = false;
        this.string_maps = null;
        this.text_encoder = new TextEncoder();
        let initial_size;
        if (!opt_initial_size) {
            initial_size = 1024;
        }
        else {
            initial_size = opt_initial_size;
        }
        /**
         * @type {ByteBuffer}
         * @private
         */
        this.bb = _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__.ByteBuffer.allocate(initial_size);
        this.space = initial_size;
    }
    clear() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
        this.string_maps = null;
    }
    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param forceDefaults true always serializes default values
     */
    forceDefaults(forceDefaults) {
        this.force_defaults = forceDefaults;
    }
    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     */
    dataBuffer() {
        return this.bb;
    }
    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     */
    asUint8Array() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param size This is the of the new element to write
     * @param additional_bytes The padding size
     */
    prep(size, additional_bytes) {
        // Track the biggest thing we've ever aligned to.
        if (size > this.minalign) {
            this.minalign = size;
        }
        // Find the amount of alignment needed such that `size` is properly
        // aligned after `additional_bytes`
        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);
        // Reallocate the buffer if needed.
        while (this.space < align_size + size + additional_bytes) {
            const old_buf_size = this.bb.capacity();
            this.bb = Builder.growByteBuffer(this.bb);
            this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
    }
    pad(byte_size) {
        for (let i = 0; i < byte_size; i++) {
            this.bb.writeInt8(--this.space, 0);
        }
    }
    writeInt8(value) {
        this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
        this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
        this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
        this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
        this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
        this.bb.writeFloat64(this.space -= 8, value);
    }
    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int8` to add the buffer.
     */
    addInt8(value) {
        this.prep(1, 0);
        this.writeInt8(value);
    }
    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int16` to add the buffer.
     */
    addInt16(value) {
        this.prep(2, 0);
        this.writeInt16(value);
    }
    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int32` to add the buffer.
     */
    addInt32(value) {
        this.prep(4, 0);
        this.writeInt32(value);
    }
    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int64` to add the buffer.
     */
    addInt64(value) {
        this.prep(8, 0);
        this.writeInt64(value);
    }
    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float32` to add the buffer.
     */
    addFloat32(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
    }
    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float64` to add the buffer.
     */
    addFloat64(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt8(value);
            this.slot(voffset);
        }
    }
    addFieldInt16(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt16(value);
            this.slot(voffset);
        }
    }
    addFieldInt32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt32(value);
            this.slot(voffset);
        }
    }
    addFieldInt64(voffset, value, defaultValue) {
        if (this.force_defaults || value !== defaultValue) {
            this.addInt64(value);
            this.slot(voffset);
        }
    }
    addFieldFloat32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat32(value);
            this.slot(voffset);
        }
    }
    addFieldFloat64(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat64(value);
            this.slot(voffset);
        }
    }
    addFieldOffset(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addOffset(value);
            this.slot(voffset);
        }
    }
    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     */
    addFieldStruct(voffset, value, defaultValue) {
        if (value != defaultValue) {
            this.nested(value);
            this.slot(voffset);
        }
    }
    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     */
    nested(obj) {
        if (obj != this.offset()) {
            throw new TypeError('FlatBuffers: struct must be serialized inline.');
        }
    }
    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */
    notNested() {
        if (this.isNested) {
            throw new TypeError('FlatBuffers: object serialization must not be nested.');
        }
    }
    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     */
    slot(voffset) {
        if (this.vtable !== null)
            this.vtable[voffset] = this.offset();
    }
    /**
     * @returns Offset relative to the end of the buffer.
     */
    offset() {
        return this.bb.capacity() - this.space;
    }
    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param bb The current buffer with the existing data
     * @returns A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */
    static growByteBuffer(bb) {
        const old_buf_size = bb.capacity();
        // Ensure we don't grow beyond what fits in an int.
        if (old_buf_size & 0xC0000000) {
            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
        }
        const new_buf_size = old_buf_size << 1;
        const nbb = _byte_buffer_js__WEBPACK_IMPORTED_MODULE_0__.ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
    }
    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param offset The offset to add.
     */
    addOffset(offset) {
        this.prep(_constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT, 0); // Ensure alignment is already done.
        this.writeInt32(this.offset() - offset + _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT);
    }
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     */
    startObject(numfields) {
        this.notNested();
        if (this.vtable == null) {
            this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for (let i = 0; i < numfields; i++) {
            this.vtable[i] = 0; // This will push additional elements as needed
        }
        this.isNested = true;
        this.object_start = this.offset();
    }
    /**
     * Finish off writing the object that is under construction.
     *
     * @returns The offset to the object inside `dataBuffer`
     */
    endObject() {
        if (this.vtable == null || !this.isNested) {
            throw new Error('FlatBuffers: endObject called without startObject');
        }
        this.addInt32(0);
        const vtableloc = this.offset();
        // Trim trailing zeroes.
        let i = this.vtable_in_use - 1;
        // eslint-disable-next-line no-empty
        for (; i >= 0 && this.vtable[i] == 0; i--) { }
        const trimmed_size = i + 1;
        // Write out the current vtable.
        for (; i >= 0; i--) {
            // Offset relative to the start of the table.
            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        const standard_fields = 2; // The fields below:
        this.addInt16(vtableloc - this.object_start);
        const len = (trimmed_size + standard_fields) * _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT;
        this.addInt16(len);
        // Search for an existing vtable that matches the current one.
        let existing_vtable = 0;
        const vt1 = this.space;
        outer_loop: for (i = 0; i < this.vtables.length; i++) {
            const vt2 = this.bb.capacity() - this.vtables[i];
            if (len == this.bb.readInt16(vt2)) {
                for (let j = _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT; j < len; j += _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_SHORT) {
                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                        continue outer_loop;
                    }
                }
                existing_vtable = this.vtables[i];
                break;
            }
        }
        if (existing_vtable) {
            // Found a match:
            // Remove the current vtable.
            this.space = this.bb.capacity() - vtableloc;
            // Point table to existing vtable.
            this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        }
        else {
            // No match:
            // Add the location of the current vtable to the list of vtables.
            this.vtables.push(this.offset());
            // Point table to current vtable.
            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
    }
    /**
     * Finalize a buffer, poiting to the given `root_table`.
     */
    finish(root_table, opt_file_identifier, opt_size_prefix) {
        const size_prefix = opt_size_prefix ? _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
            const file_identifier = opt_file_identifier;
            this.prep(this.minalign, _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT +
                _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH + size_prefix);
            if (file_identifier.length != _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH) {
                throw new TypeError('FlatBuffers: file identifier must be length ' +
                    _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH);
            }
            for (let i = _constants_js__WEBPACK_IMPORTED_MODULE_1__.FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
                this.writeInt8(file_identifier.charCodeAt(i));
            }
        }
        this.prep(this.minalign, _constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
            this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
    }
    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     */
    finishSizePrefixed(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
    }
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     */
    requiredField(table, field) {
        const table_start = this.bb.capacity() - table;
        const vtable_start = table_start - this.bb.readInt32(table_start);
        const ok = field < this.bb.readInt16(vtable_start) &&
            this.bb.readInt16(vtable_start + field) != 0;
        // If this fails, the caller will show what field needs to be set.
        if (!ok) {
            throw new TypeError('FlatBuffers: field ' + field + ' must be set');
        }
    }
    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param elem_size The size of each element in the array
     * @param num_elems The number of elements in the array
     * @param alignment The alignment of the array
     */
    startVector(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(_constants_js__WEBPACK_IMPORTED_MODULE_1__.SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
    }
    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns The offset at which the newly created array
     * starts.
     */
    endVector() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If the string passed has
     * already been seen, we return the offset of the already written string
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createSharedString(s) {
        if (!s) {
            return 0;
        }
        if (!this.string_maps) {
            this.string_maps = new Map();
        }
        if (this.string_maps.has(s)) {
            return this.string_maps.get(s);
        }
        const offset = this.createString(s);
        this.string_maps.set(s, offset);
        return offset;
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createString(s) {
        if (s === null || s === undefined) {
            return 0;
        }
        let utf8;
        if (s instanceof Uint8Array) {
            utf8 = s;
        }
        else {
            utf8 = this.text_encoder.encode(s);
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        this.bb.bytes().set(utf8, this.space);
        return this.endVector();
    }
    /**
     * Create a byte vector.
     *
     * @param v The bytes to add
     * @returns The offset in the buffer where the byte vector starts
     */
    createByteVector(v) {
        if (v === null || v === undefined) {
            return 0;
        }
        this.startVector(1, v.length, 1);
        this.bb.setPosition(this.space -= v.length);
        this.bb.bytes().set(v, this.space);
        return this.endVector();
    }
    /**
     * A helper function to pack an object
     *
     * @returns offset of obj
     */
    createObjectOffset(obj) {
        if (obj === null) {
            return 0;
        }
        if (typeof obj === 'string') {
            return this.createString(obj);
        }
        else {
            return obj.pack(this);
        }
    }
    /**
     * A helper function to pack a list of object
     *
     * @returns list of offsets of each non null object
     */
    createObjectOffsetList(list) {
        const ret = [];
        for (let i = 0; i < list.length; ++i) {
            const val = list[i];
            if (val !== null) {
                ret.push(this.createObjectOffset(val));
            }
            else {
                throw new TypeError('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');
            }
        }
        return ret;
    }
    createStructOffsetList(list, startFunc) {
        startFunc(this, list.length);
        this.createObjectOffsetList(list.slice().reverse());
        return this.endVector();
    }
}


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/byte-buffer.js":
/*!*****************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/byte-buffer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ByteBuffer: () => (/* binding */ ByteBuffer)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/flatbuffers/mjs/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/flatbuffers/mjs/utils.js");
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/flatbuffers/mjs/encoding.js");



class ByteBuffer {
    /**
     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
     */
    constructor(bytes_) {
        this.bytes_ = bytes_;
        this.position_ = 0;
        this.text_decoder_ = new TextDecoder();
    }
    /**
     * Create and allocate a new ByteBuffer with a given size.
     */
    static allocate(byte_size) {
        return new ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
        this.position_ = 0;
    }
    /**
     * Get the underlying `Uint8Array`.
     */
    bytes() {
        return this.bytes_;
    }
    /**
     * Get the buffer's position.
     */
    position() {
        return this.position_;
    }
    /**
     * Set the buffer's position.
     */
    setPosition(position) {
        this.position_ = position;
    }
    /**
     * Get the buffer's capacity.
     */
    capacity() {
        return this.bytes_.length;
    }
    readInt8(offset) {
        return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
        return this.bytes_[offset];
    }
    readInt16(offset) {
        return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
        return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readUint64(offset) {
        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readFloat32(offset) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[0] = this.readInt32(offset);
        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32[0];
    }
    readFloat64(offset) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 0 : 1] = this.readInt32(offset);
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64[0];
    }
    writeInt8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    }
    writeUint64(offset, value) {
        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    }
    writeFloat32(offset, value) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32[0] = value;
        this.writeInt32(offset, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[0]);
    }
    writeFloat64(offset, value) {
        _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64[0] = value;
        this.writeInt32(offset, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32[_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian ? 1 : 0]);
    }
    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     */
    getBufferIdentifier() {
        if (this.bytes_.length < this.position_ + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT +
            _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');
        }
        let result = "";
        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH; i++) {
            result += String.fromCharCode(this.readInt8(this.position_ + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT + i));
        }
        return result;
    }
    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     */
    __offset(bb_pos, vtable_offset) {
        const vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     */
    __union(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
    }
    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
     * "optionalEncoding" argument. This is useful for avoiding conversion when
     * the data will just be packaged back up in another FlatBuffer later on.
     *
     * @param offset
     * @param opt_encoding Defaults to UTF16_STRING
     */
    __string(offset, opt_encoding) {
        offset += this.readInt32(offset);
        const length = this.readInt32(offset);
        offset += _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT;
        const utf8bytes = this.bytes_.subarray(offset, offset + length);
        if (opt_encoding === _encoding_js__WEBPACK_IMPORTED_MODULE_2__.Encoding.UTF8_BYTES)
            return utf8bytes;
        else
            return this.text_decoder_.decode(utf8bytes);
    }
    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
     * if a string then return a new one
     *
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
     * makes the behaviour of __union_with_string different compared to __union
     */
    __union_with_string(o, offset) {
        if (typeof o === 'string') {
            return this.__string(offset);
        }
        return this.__union(o, offset);
    }
    /**
     * Retrieve the relative offset stored at "offset"
     */
    __indirect(offset) {
        return offset + this.readInt32(offset);
    }
    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     */
    __vector(offset) {
        return offset + this.readInt32(offset) + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT; // data starts after the length
    }
    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     */
    __vector_len(offset) {
        return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
        if (ident.length != _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: file identifier must be length ' +
                _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH);
        }
        for (let i = 0; i < _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH; i++) {
            if (ident.charCodeAt(i) != this.readInt8(this.position() + _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT + i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * A helper function for generating list for obj api
     */
    createScalarList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val);
            }
        }
        return ret;
    }
    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength listLength
     * @param res result list
     */
    createObjList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val.unpack());
            }
        }
        return ret;
    }
}


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/constants.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FILE_IDENTIFIER_LENGTH: () => (/* binding */ FILE_IDENTIFIER_LENGTH),
/* harmony export */   SIZEOF_INT: () => (/* binding */ SIZEOF_INT),
/* harmony export */   SIZEOF_SHORT: () => (/* binding */ SIZEOF_SHORT),
/* harmony export */   SIZE_PREFIX_LENGTH: () => (/* binding */ SIZE_PREFIX_LENGTH)
/* harmony export */ });
const SIZEOF_SHORT = 2;
const SIZEOF_INT = 4;
const FILE_IDENTIFIER_LENGTH = 4;
const SIZE_PREFIX_LENGTH = 4;


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/encoding.js":
/*!**************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/encoding.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Encoding: () => (/* binding */ Encoding)
/* harmony export */ });
var Encoding;
(function (Encoding) {
    Encoding[Encoding["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding[Encoding["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));


/***/ }),

/***/ "./node_modules/flatbuffers/mjs/flatbuffers.js":
/*!*****************************************************!*\
  !*** ./node_modules/flatbuffers/mjs/flatbuffers.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Builder: () => (/* reexport safe */ _builder_js__WEBPACK_IMPORTED_MODULE_3__.Builder),
/* harmony export */   ByteBuffer: () => (/* reexport safe */ _byte_buffer_js__WEBPACK_IMPORTED_MODULE_4__.ByteBuffer),
/* harmony export */   Encoding: () => (/* reexport safe */ _encoding_js__WEBPACK_IMPORTED_MODULE_2__.Encoding),
/* harmony export */   FILE_IDENTIFIER_LENGTH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.FILE_IDENTIFIER_LENGTH),
/* harmony export */   SIZEOF_INT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_INT),
/* harmony export */   SIZEOF_SHORT: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZEOF_SHORT),
/* harmony export */   SIZE_PREFIX_LENGTH: () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_0__.SIZE_PREFIX_LENGTH),
/* harmony export */   float32: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.float32),
/* harmony export */   float64: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.float64),
/* harmony export */   int32: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.int32),
/* harmony export */   isLittleEndian: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.isLittleEndian)
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./node_modules/flatbuffers/mjs/constants.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/flatbuffers/mjs/utils.js");
/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/flatbuffers/mjs/encoding.js");
/* harmony import */ var _builder_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./builder.js */ "./node_modules/flatbuffers/mjs/builder.js");
/* harmony import */ var _byte_buffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./byte-buffer.js */ "./node_modules/flatbuffers/mjs/byte-buffer.js");










/***/ }),

/***/ "./node_modules/flatbuffers/mjs/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/flatbuffers/mjs/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   float32: () => (/* binding */ float32),
/* harmony export */   float64: () => (/* binding */ float64),
/* harmony export */   int32: () => (/* binding */ int32),
/* harmony export */   isLittleEndian: () => (/* binding */ isLittleEndian)
/* harmony export */ });
const int32 = new Int32Array(2);
const float32 = new Float32Array(int32.buffer);
const float64 = new Float64Array(int32.buffer);
const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;


/***/ }),

/***/ "./node_modules/lodash.range/index.js":
/*!********************************************!*\
  !*** ./node_modules/lodash.range/index.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991,
    MAX_INTEGER = 1.7976931348623157e+308,
    NAN = 0 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;


/***/ }),

/***/ "./node_modules/normalize.css/normalize.css":
/*!**************************************************!*\
  !*** ./node_modules/normalize.css/normalize.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/index-style.css":
/*!*****************************!*\
  !*** ./src/index-style.css ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/daily-forecast-style.css":
/*!*********************************************!*\
  !*** ./src/styles/daily-forecast-style.css ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/feels-like-style.css":
/*!*****************************************!*\
  !*** ./src/styles/feels-like-style.css ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/hourly-forecast-style.css":
/*!**********************************************!*\
  !*** ./src/styles/hourly-forecast-style.css ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/pressure-style.css":
/*!***************************************!*\
  !*** ./src/styles/pressure-style.css ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/sunrise-sunset-style.css":
/*!*********************************************!*\
  !*** ./src/styles/sunrise-sunset-style.css ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/uv-index-style.css":
/*!***************************************!*\
  !*** ./src/styles/uv-index-style.css ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/styles/wind-style.css":
/*!***********************************!*\
  !*** ./src/styles/wind-style.css ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/openmeteo/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/openmeteo/lib/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fetchWeatherApi = void 0;
const flatbuffers_1 = __webpack_require__(/*! flatbuffers */ "./node_modules/flatbuffers/mjs/flatbuffers.js");
const weather_api_response_1 = __webpack_require__(/*! @openmeteo/sdk/weather-api-response */ "./node_modules/@openmeteo/sdk/weather-api-response.js");
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
function fetchRetried(url_1) {
    return __awaiter(this, arguments, void 0, function* (url, retries = 3, backoffFactor = 0.5, backoffMax = 2) {
        const statusToRetry = [500, 502, 504];
        const statusWithJsonError = [400, 429];
        let currentTry = 0;
        let response = yield fetch(url);
        while (statusToRetry.includes(response.status)) {
            currentTry++;
            if (currentTry >= retries) {
                throw new Error(response.statusText);
            }
            const sleepMs = Math.min(backoffFactor * Math.pow(2, currentTry), backoffMax) * 1000;
            yield sleep(sleepMs);
            response = yield fetch(url);
        }
        if (statusWithJsonError.includes(response.status)) {
            const json = yield response.json();
            if ('reason' in json) {
                throw new Error(json.reason);
            }
            throw new Error(response.statusText);
        }
        return response;
    });
}
/**
 * Retrieve data from the Open-Meteo weather API
 *
 * @param {string} url Server and endpoint. E.g. "https://api.open-meteo.com/v1/forecast"
 * @param {any} params URL parameter as an object
 * @param {number} [retries=3] Number of retries in case of an server error
 * @param {number} [backoffFactor=0.2] Exponential backoff factor to increase wait time after each retry
 * @param {number} [backoffMax=2] Maximum wait time between retries
 * @returns {Promise<WeatherApiResponse[]>}
 */
function fetchWeatherApi(url_1, params_1) {
    return __awaiter(this, arguments, void 0, function* (url, params, retries = 3, backoffFactor = 0.2, backoffMax = 2) {
        const urlParams = new URLSearchParams(params);
        urlParams.set('format', 'flatbuffers');
        const response = yield fetchRetried(`${url}?${urlParams.toString()}`, retries, backoffFactor, backoffMax);
        const fb = new flatbuffers_1.ByteBuffer(new Uint8Array(yield response.arrayBuffer()));
        const results = [];
        let pos = 0;
        while (pos < fb.capacity()) {
            fb.setPosition(pos);
            const len = fb.readInt32(fb.position());
            results.push(weather_api_response_1.WeatherApiResponse.getSizePrefixedRootAsWeatherApiResponse(fb));
            pos += len + 4;
        }
        return results;
    });
}
exports.fetchWeatherApi = fetchWeatherApi;


/***/ }),

/***/ "./node_modules/svg-gauge/index.js":
/*!*****************************************!*\
  !*** ./node_modules/svg-gauge/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./src/gauge */ "./node_modules/svg-gauge/src/gauge.js");


/***/ }),

/***/ "./node_modules/svg-gauge/src/gauge.js":
/*!*********************************************!*\
  !*** ./node_modules/svg-gauge/src/gauge.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, define, module */
(function(global, factory) {
  var Gauge = factory(global);
  if(true) {
    // AMD support
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {return Gauge;}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }else {}
})(typeof window === "undefined" ? this : window, function(global, undefined) {

  var document = global.document,
    slice = Array.prototype.slice,
    requestAnimationFrame = (global.requestAnimationFrame ||
        global.mozRequestAnimationFrame ||
        global.webkitRequestAnimationFrame ||
        global.msRequestAnimationFrame ||
        function(cb) {
          return setTimeout(cb, 1000 / 60);
        });

  // EXPERIMENTAL!!
  /**
   * Simplistic animation function for animating the gauge. That's all!
   * Options are:
   * {
   *  duration: 1,    // In seconds
   *  start: 0,       // The start value
   *  end: 100,       // The end value
   *  step: function, // REQUIRED! The step function that will be passed the value and does something
   *  easing: function // The easing function. Default is easeInOutCubic
   * }
   */
  function Animation(options) {
    var duration = options.duration,
        currentIteration = 1,
        iterations = 60 * duration,
        start = options.start || 0,
        end = options.end,
        change = end - start,
        step = options.step,
        easing = options.easing || function easeInOutCubic(pos) {
          // https://github.com/danro/easing-js/blob/master/easing.js
          if ((pos/=0.5) < 1) return 0.5*Math.pow(pos,3);
          return 0.5 * (Math.pow((pos-2),3) + 2);
        };

    function animate() {
      var progress = currentIteration / iterations, 
          value = change * easing(progress) + start;
      // console.log(progress + ", " + value);
      step(value, currentIteration);
      currentIteration += 1;

      if(progress < 1) {
        requestAnimationFrame(animate);
      }
    }
    // start!
    requestAnimationFrame(animate);
  }



  var Gauge = (function() {
    var SVG_NS = "http://www.w3.org/2000/svg";

    var GaugeDefaults = {
      centerX: 50,
      centerY: 50
    };

    var defaultOptions = {
      dialRadius: 40,
      dialStartAngle: 135,
      dialEndAngle: 45,
      value: 0,
      max: 100,
      min: 0,
      valueDialClass: "value",
      valueClass: "value-text",
      dialClass: "dial",
      gaugeClass: "gauge",
      showValue: true,
      gaugeColor: null,
      label: function(val) {return Math.round(val);}
    };

    function shallowCopy(/* source, ...targets*/) {
      var target = arguments[0], sources = slice.call(arguments, 1);
      sources.forEach(function(s) {
        for(var k in s) {
          if(s.hasOwnProperty(k)) {
            target[k] = s[k];
          }
        }
      });
      return target;
    }

    /**
     * A utility function to create SVG dom tree
     * @param {String} name The SVG element name
     * @param {Object} attrs The attributes as they appear in DOM e.g. stroke-width and not strokeWidth
     * @param {Array} children An array of children (can be created by this same function)
     * @return The SVG element
     */
    function svg(name, attrs, children) {
      var elem = document.createElementNS(SVG_NS, name);
      for(var attrName in attrs) {
        elem.setAttribute(attrName, attrs[attrName]);
      }

      if(children) {
        children.forEach(function(c) {
          elem.appendChild(c);
        });
      }
      return elem;
    }

    /**
     * Translates percentage value to angle. e.g. If gauge span angle is 180deg, then 50%
     * will be 90deg
     */
    function getAngle(percentage, gaugeSpanAngle) {
      return percentage * gaugeSpanAngle / 100;
    }

    function normalize(value, min, limit) {
      var val = Number(value);
      if(val > limit) return limit;
      if(val < min) return min;
      return val;
    }

    function getValueInPercentage(value, min, max) {
      var newMax = max - min, newVal = value - min;
      return 100 * newVal / newMax;
      // var absMin = Math.abs(min);
      // return 100 * (absMin + value) / (max + absMin);
    }

    /**
     * Gets cartesian co-ordinates for a specified radius and angle (in degrees)
     * @param cx {Number} The center x co-oriinate
     * @param cy {Number} The center y co-ordinate
     * @param radius {Number} The radius of the circle
     * @param angle {Number} The angle in degrees
     * @return An object with x,y co-ordinates
     */
    function getCartesian(cx, cy, radius, angle) {
      var rad = angle * Math.PI / 180;
      return {
        x: Math.round((cx + radius * Math.cos(rad)) * 1000) / 1000,
        y: Math.round((cy + radius * Math.sin(rad)) * 1000) / 1000
      };
    }

    // Returns start and end points for dial
    // i.e. starts at 135deg ends at 45deg with large arc flag
    // REMEMBER!! angle=0 starts on X axis and then increases clockwise
    function getDialCoords(radius, startAngle, endAngle) {
      var cx = GaugeDefaults.centerX,
          cy = GaugeDefaults.centerY;
      return {
        end: getCartesian(cx, cy, radius, endAngle),
      	start: getCartesian(cx, cy, radius, startAngle)
      };
    }

    /**
     * Creates a Gauge object. This should be called without the 'new' operator. Various options
     * can be passed for the gauge:
     * {
     *    dialStartAngle: The angle to start the dial. MUST be greater than dialEndAngle. Default 135deg
     *    dialEndAngle: The angle to end the dial. Default 45deg
     *    dialRadius: The gauge's radius. Default 400
     *    max: The maximum value of the gauge. Default 100
     *    value: The starting value of the gauge. Default 0
     *    label: The function on how to render the center label (Should return a value)
     * }
     * @param {Element} elem The DOM into which to render the gauge
     * @param {Object} opts The gauge options
     * @return a Gauge object
     */
    return function Gauge(elem, opts) {
      opts = shallowCopy({}, defaultOptions, opts);
      var gaugeContainer = elem,
          limit = opts.max,
          min = opts.min,
          value = normalize(opts.value, min, limit),
          radius = opts.dialRadius,
          displayValue = opts.showValue,
          startAngle = opts.dialStartAngle,
          endAngle = opts.dialEndAngle,
          valueDialClass = opts.valueDialClass,
          valueTextClass = opts.valueClass,
          valueLabelClass = opts.valueLabelClass,
          dialClass = opts.dialClass,
          gaugeClass = opts.gaugeClass,
          gaugeColor = opts.color,
          gaugeValueElem,
          gaugeValuePath,
          label = opts.label,
          viewBox = opts.viewBox,
          instance;

      if(startAngle < endAngle) {
        console.log("WARN! startAngle < endAngle, Swapping");
        var tmp = startAngle;
        startAngle = endAngle;
        endAngle = tmp;
      }

      function pathString(radius, startAngle, endAngle, largeArc) {
        var coords = getDialCoords(radius, startAngle, endAngle),
            start = coords.start,
            end = coords.end,
            largeArcFlag = typeof(largeArc) === "undefined" ? 1 : largeArc;

        return [
          "M", start.x, start.y, 
          "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y
        ].join(" ");
      }

      function initializeGauge(elem) {
        gaugeValueElem = svg("text", {
          x: 50,
          y: 50,
          fill: "#999",
          "class": valueTextClass,
          "font-size": "100%",
          "font-family": "sans-serif",
          "font-weight": "normal",
          "text-anchor": "middle",
          "alignment-baseline": "middle",
          "dominant-baseline": "central"
        });

        gaugeValuePath = svg("path", {
          "class": valueDialClass,
          fill: "none",
          stroke: "#666",
          "stroke-width": 2.5,
          d: pathString(radius, startAngle, startAngle) // value of 0
        });

        var angle = getAngle(100, 360 - Math.abs(startAngle - endAngle));
        var flag = angle <= 180 ? 0 : 1;
        var gaugeElement = svg("svg", {"viewBox": viewBox || "0 0 100 100", "class": gaugeClass}, [
          svg("path", {
            "class": dialClass,
            fill: "none",
            stroke: "#eee",
            "stroke-width": 2,
            d: pathString(radius, startAngle, endAngle, flag)
          }),
          svg("g", { "class": "text-container" }, [gaugeValueElem]),
          gaugeValuePath
        ]);
        elem.appendChild(gaugeElement);
      }

      function updateGauge(theValue, frame) {
        var val = getValueInPercentage(theValue, min, limit),
            // angle = getAngle(val, 360 - Math.abs(endAngle - startAngle)),
            angle = getAngle(val, 360 - Math.abs(startAngle - endAngle)),
            // this is because we are using arc greater than 180deg
            flag = angle <= 180 ? 0 : 1;
        if(displayValue) {
          gaugeValueElem.textContent = label.call(opts, theValue);
        }
        gaugeValuePath.setAttribute("d", pathString(radius, startAngle, angle + startAngle, flag));
      }

      function setGaugeColor(value, duration) {        
        var c = gaugeColor.call(opts, value), 
            dur = duration * 1000,
            pathTransition = "stroke " + dur + "ms ease";
            // textTransition = "fill " + dur + "ms ease";

        gaugeValuePath.style.stroke = c;
        gaugeValuePath.style["-webkit-transition"] = pathTransition;
        gaugeValuePath.style["-moz-transition"] = pathTransition;
        gaugeValuePath.style.transition = pathTransition;
        /*
        gaugeValueElem.style = [
          "fill: " + c,
          "-webkit-transition: " + textTransition,
          "-moz-transition: " + textTransition,
          "transition: " + textTransition,
        ].join(";");
        */
      }

      instance = {
        setMaxValue: function(max) {
          limit = max;
          updateGauge(value);
        },
        setValue: function(val) {
          value = normalize(val, min, limit);
          if(gaugeColor) {
            setGaugeColor(value, 0)
          }
          updateGauge(value);
        },
        setValueAnimated: function(val, duration) {
        	var oldVal = value;
          value = normalize(val, min, limit);
          if(oldVal === value) {
            return;
          }

          if(gaugeColor) {
            setGaugeColor(value, duration);
          }
          Animation({
            start: oldVal || 0,
            end: value,
            duration: duration || 1,
            step: function(val, frame) {
              updateGauge(val, frame);
            }
          });
        },
        getValue: function() {
          return value;
        }
      };

      initializeGauge(gaugeContainer);
      instance.setValue(value);
      return instance;
    };
  })();

  return Gauge;
});


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var normalize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! normalize.css */ "./node_modules/normalize.css/normalize.css");
/* harmony import */ var _index_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-style.css */ "./src/index-style.css");
/* harmony import */ var _modules_weather__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/weather */ "./src/modules/weather.js");
/* harmony import */ var _modules_domController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/domController */ "./src/modules/domController.js");
/* eslint-disable import/no-extraneous-dependencies */





const locationData = (0,_modules_weather__WEBPACK_IMPORTED_MODULE_2__["default"])('postojna');
locationData.then((res) => console.log(res));
locationData.then((res) => (0,_modules_domController__WEBPACK_IMPORTED_MODULE_3__["default"])(res, 'metric'));


/***/ }),

/***/ "./src/modules/domController.js":
/*!**************************************!*\
  !*** ./src/modules/domController.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ updateWeatherInfo)
/* harmony export */ });
/* harmony import */ var _styles_hourly_forecast_style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/hourly-forecast-style.css */ "./src/styles/hourly-forecast-style.css");
/* harmony import */ var _styles_daily_forecast_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/daily-forecast-style.css */ "./src/styles/daily-forecast-style.css");
/* harmony import */ var _styles_feels_like_style_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/feels-like-style.css */ "./src/styles/feels-like-style.css");
/* harmony import */ var _styles_uv_index_style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/uv-index-style.css */ "./src/styles/uv-index-style.css");
/* harmony import */ var _styles_sunrise_sunset_style_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles/sunrise-sunset-style.css */ "./src/styles/sunrise-sunset-style.css");
/* harmony import */ var _styles_wind_style_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/wind-style.css */ "./src/styles/wind-style.css");
/* harmony import */ var _styles_pressure_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/pressure-style.css */ "./src/styles/pressure-style.css");
/* harmony import */ var _assets_icons_sunset_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../assets/icons/sunset.svg */ "./src/assets/icons/sunset.svg");
/* harmony import */ var _assets_icons_sunrise_svg__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../assets/icons/sunrise.svg */ "./src/assets/icons/sunrise.svg");
/* harmony import */ var _assets_json_weatherCodes_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../assets/json/weatherCodes.json */ "./src/assets/json/weatherCodes.json");
/* harmony import */ var _tempBar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tempBar */ "./src/modules/tempBar.js");
/* harmony import */ var _timezoneFormatter__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./timezoneFormatter */ "./src/modules/timezoneFormatter.js");
/* harmony import */ var _pressureGauge__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pressureGauge */ "./src/modules/pressureGauge.js");
/* eslint-disable no-lonely-if */
/* eslint-disable no-plusplus */














const degreeIcon = '\u{000B0}';

const getWeatherType = (weatherCode, isDay) => {
    const dayType = isDay === 1 ? 'day' : 'night';

    return _assets_json_weatherCodes_json__WEBPACK_IMPORTED_MODULE_9__[weatherCode][dayType];
};

const updateBriefInfo = (locationData, systemType) => {
    const locationBriefInfo = document.querySelector('.location-brief-info');
    const cityElement = locationBriefInfo.querySelector('.city');
    const tempElement = locationBriefInfo.querySelector('.temp');
    const typeElement = locationBriefInfo.querySelector('.type');
    const tempMaxElement = locationBriefInfo.querySelector('.temp-high');
    const tempMinElement = locationBriefInfo.querySelector('.temp-low');

    const name = locationData.location.name.split(',')[0];
    cityElement.textContent = name;

    const currentTemp = Math.round(locationData.current.temperature2m);
    const tempMax = Math.round(locationData.daily.temperature2mMax[0]);
    const tempMin = Math.round(locationData.daily.temperature2mMin[0]);

    tempElement.textContent = systemType === 'metric' ? `${currentTemp}${degreeIcon}` : Math.round(`${currentTemp}${degreeIcon}` * (9 / 5)) + 32;
    tempMaxElement.textContent = systemType === 'metric' ? `${tempMax}${degreeIcon}` : Math.round(`${tempMax}${degreeIcon}` * (9 / 5)) + 32;
    tempMinElement.textContent = systemType === 'metric' ? `${tempMin}${degreeIcon}` : Math.round(`${tempMin}${degreeIcon}` * (9 / 5)) + 32;

    const weatherType = getWeatherType(
        locationData.current.weatherCode,
        locationData.current.isDay,
    );
    typeElement.textContent = weatherType.description;
};

const updateHourlyForecast = (locationData, systemType) => {
    const hourly = document.querySelector('.hourly-forecast');
    const card = hourly.querySelector('.card-content');

    // create first element in card content to be Now
    // create 23 items for next 23 hours
    // total 24 items
    for (let i = 0; i < 24; i++) {
        const item = document.createElement('div');
        item.classList.add('js-hour-item');

        const hourTime = document.createElement('p');
        hourTime.classList.add('js-hour-time');
        const hour = i === 0 ? 'Now' : new Date(locationData.hourly.time[i]).getHours();
        hourTime.textContent = hour;
        const hourWeatherType = document.createElement('img');
        hourWeatherType.classList.add('js-hour-weather-type');
        hourWeatherType.setAttribute('alt', 'Weather type icon');
        hourWeatherType.setAttribute('height', '24');
        const weatherType = getWeatherType(
            locationData.hourly.weatherCode[i],
            locationData.hourly.isDay[i],
        );
        hourWeatherType.src = weatherType.image;
        const hourTemp = document.createElement('p');
        hourTemp.classList.add('js-hour-temp');
        const temp = systemType === 'metric' ? Math.round(locationData.hourly.temperature2m[i]) : Math.round((locationData.hourly.temperature2m[i] * (9 / 5)) + 32);
        hourTemp.textContent = `${temp}${degreeIcon}`;

        item.append(hourTime, hourWeatherType, hourTemp);
        card.append(item);
    }
};

const updateDailyForecast = (locationData, systemType) => {
    const daily = document.querySelector('.daily-forecast');
    const card = daily.querySelector('.card-content');

    // create first element for today
    // create 9 elements for following days
    // total 10 elements
    const weekday = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    for (let i = 7; i < 18; i++) {
        const hr = document.createElement('hr');
        const item = document.createElement('div');
        item.classList.add('js-daily-item');

        const dayNameElement = document.createElement('p');
        dayNameElement.classList.add('js-day-name');
        const day = new Date(locationData.daily.time[i]).getDay();
        dayNameElement.textContent = i === 7 ? 'Today' : weekday[day];
        const dailyWeatherTypeElement = document.createElement('img');
        dailyWeatherTypeElement.classList.add('js-hour-weather-type');
        dailyWeatherTypeElement.setAttribute('alt', 'Weather type icon');
        dailyWeatherTypeElement.setAttribute('height', '24');
        const weatherType = getWeatherType(
            locationData.daily.weatherCode[i],
            1,
        );
        dailyWeatherTypeElement.src = weatherType.image;
        const minTempElement = document.createElement('p');
        const maxTempElement = document.createElement('p');
        minTempElement.classList.add('js-daily-temp-min');
        maxTempElement.classList.add('js-daily-temp-max');

        const minTemp = systemType === 'metric' ? Math.round(locationData.daily.temperature2mMin[i]) : Math.round((locationData.daily.temperature2mMin[i] * (9 / 5)) + 32);
        minTempElement.textContent = `${minTemp}${degreeIcon}`;

        const maxTemp = systemType === 'metric' ? Math.round(locationData.daily.temperature2mMax[i]) : Math.round((locationData.daily.temperature2mMax[i] * (9 / 5)) + 32);
        maxTempElement.textContent = `${maxTemp}${degreeIcon}`;

        const barElement = (0,_tempBar__WEBPACK_IMPORTED_MODULE_10__["default"])(minTemp, maxTemp);

        item.append(
            dayNameElement,
            dailyWeatherTypeElement,
            minTempElement,
            barElement,
            maxTempElement,
        );

        if (i < 17) {
            card.append(item, hr);
        } else {
            card.append(item);
        }
    }
};

const updateFeelsLike = (locationData, systemType) => {
    const feels = document.querySelector('.feels-like');
    const card = feels.querySelector('.card-content');
    const feelsLikeTemp = Math.round(locationData.current.apparentTemperature);
    const currentTemp = Math.round(locationData.current.temperature2m);

    const temp = document.createElement('div');
    temp.classList.add('js-feels-temp');
    temp.textContent = systemType === 'metric' ? `${feelsLikeTemp}${degreeIcon}` : Math.round(`${feelsLikeTemp}${degreeIcon}` * (9 / 5)) + 32;

    const desc = document.createElement('div');
    desc.classList.add('js-feels-desc');

    const tempDif = feelsLikeTemp - currentTemp;
    if (systemType === 'metric') {
        if (Math.abs(tempDif) <= 3) desc.textContent = 'Similar to the actual temperature.';
        else if (tempDif > 3) desc.textContent = 'Hotter than the actual temperature.';
        else if (tempDif > -3) desc.textContent = 'Colder than the actual temperature.';
    } else {
        if (Math.abs(tempDif) <= 6) desc.textContent = 'Similar to the actual temperature.';
        else if (tempDif > 6) desc.textContent = 'Hotter than the actual temperature.';
        else if (tempDif > -6) desc.textContent = 'Colder than the actual temperature.';
    }

    card.append(temp, desc);
};

const updateUvIndex = (locationData) => {
    const uvIndex = document.querySelector('.uv-index');
    const card = uvIndex.querySelector('.card-content');
    const index = Math.round(locationData.hourly.uvIndex[0]);

    const indexDiv = document.createElement('div');
    indexDiv.classList.add('js-uv-index');
    const indexNumber = document.createElement('p');
    indexNumber.classList.add('js-index');
    indexNumber.textContent = index;
    const indexScale = document.createElement('p');
    indexScale.classList.add('js-scale');

    const indexDesc = document.createElement('div');
    indexDesc.classList.add('js-uv-desc');
    if (index >= 0 && index <= 2) {
        indexScale.textContent = 'Normal';
        indexDesc.textContent = 'You can safely stay outside.';
    } else if (index >= 3 && index <= 5) {
        indexScale.textContent = 'Moderate';
        indexDesc.textContent = 'Use sun protection.';
    } else if (index >= 6 && index <= 7) {
        indexScale.textContent = 'High';
        indexDesc.textContent = 'Use sun protection and seek shade.';
    } else if (index >= 8 && index <= 10) {
        indexScale.textContent = 'Very high';
        indexDesc.textContent = 'Avoid being outside.';
    } else if (index >= 11) {
        indexScale.textContent = 'Extreme';
        indexDesc.textContent = 'Avoid being outside.';
    }

    const indexBarDiv = document.createElement('div');
    indexBarDiv.classList.add('js-uv-bar');
    const indexBar = document.createElement('div');
    indexBar.classList.add('js-bar');
    indexBar.style.left = index > 10 ? '100%' : `${index}0%`;

    indexDiv.append(indexNumber, indexScale);
    indexBarDiv.append(indexBar);
    card.append(indexDiv, indexBarDiv, indexDesc);
};

const updateSunriseSunset = (locationData) => {
    const sunriseSunset = document.querySelector('.sunrise-sunset');
    const card = sunriseSunset.querySelector('.card-content');
    const title = sunriseSunset.querySelector('.card-title');
    const cardTitleIcon = title.querySelector('.card-title-icon');
    const cardTitleText = title.querySelector('.card-title-text');

    const mainTime = document.createElement('div');
    mainTime.classList.add('js-sunrise-sunset-main-time');
    const nextTime = document.createElement('div');
    nextTime.classList.add('js-sunrise-sunset-next-time');

    const { timezone } = locationData.location;
    const sunriseToday = locationData.daily.sunriseSunset[0].sunrise;
    const sunsetToday = locationData.daily.sunriseSunset[0].sunset;
    const currentTime = (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_11__["default"])(timezone, new Date());

    if (currentTime.getTime() > (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_11__["default"])(timezone, new Date(sunriseToday)).getTime()
    && currentTime.getTime() < (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_11__["default"])(timezone, new Date(sunsetToday)).getTime()) {
        cardTitleText.textContent = 'Sunset';
        cardTitleIcon.src = _assets_icons_sunset_svg__WEBPACK_IMPORTED_MODULE_7__;
        cardTitleIcon.alt = 'Sunset icon';
        mainTime.textContent = sunsetToday.slice(11, 16);
        nextTime.textContent = `Sunset: ${locationData.daily.sunriseSunset[1].sunrise.slice(11, 16)}`;
    // eslint-disable-next-line max-len
    } else if (currentTime.getTime() > (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_11__["default"])(timezone, new Date(sunriseToday)).getTime()
    && currentTime.getTime() > (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_11__["default"])(timezone, new Date(sunsetToday)).getTime()) {
        cardTitleText.textContent = 'Sunrise';
        cardTitleIcon.src = _assets_icons_sunrise_svg__WEBPACK_IMPORTED_MODULE_8__;
        cardTitleIcon.alt = 'Sunrise icon';
        mainTime.textContent = locationData.daily.sunriseSunset[1].sunrise.slice(11, 16);
        nextTime.textContent = `Sunset: ${locationData.daily.sunriseSunset[1].sunset.slice(11, 16)}`;
    // eslint-disable-next-line max-len
    } else if (currentTime.getTime() < (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_11__["default"])(timezone, new Date(sunriseToday)).getTime()) {
        cardTitleText.textContent = 'Sunrise';
        cardTitleIcon.src = _assets_icons_sunrise_svg__WEBPACK_IMPORTED_MODULE_8__;
        cardTitleIcon.alt = 'Sunrise icon';
        mainTime.textContent = locationData.daily.sunriseSunset[0].sunrise.slice(11, 16);
        nextTime.textContent = `Sunset: ${sunsetToday.slice(11, 16)}`;
    }

    card.append(mainTime, nextTime);
};

const updateWind = (locationData, systemType) => {
    const wind = document.querySelector('.wind');
    const card = wind.querySelector('.card-content');
    const windType = card.querySelector('.wind-type-wind');
    const windSpeed = windType.querySelector('.wind-left');
    const windMetric = windType.querySelector('.wind-metric');
    const gustType = card.querySelector('.wind-type-gust');
    const gustSpeed = gustType.querySelector('.wind-left');
    const gustMetric = gustType.querySelector('.wind-metric');
    const windDirection = card.querySelector('.wind-direction');
    const direction = windDirection.querySelector('p');
    const arrow = windDirection.querySelector('.arrow');

    windMetric.textContent = systemType === 'metric' ? 'KM/H' : 'MP/H';
    gustMetric.textContent = systemType === 'metric' ? 'KM/H' : 'MP/H';

    const directionDegree = Math.round(locationData.current.windDirection10m);
    arrow.style.transform = `rotate(${Math.round(directionDegree)}deg)`;

    if (directionDegree >= 336 || directionDegree <= 24) {
        direction.textContent = 'N';
    } else if (directionDegree >= 25 && directionDegree <= 65) {
        direction.textContent = 'NE';
    } else if (directionDegree >= 66 && directionDegree <= 114) {
        direction.textContent = 'E';
    } else if (directionDegree >= 115 && directionDegree <= 155) {
        direction.textContent = 'SE';
    } else if (directionDegree >= 156 && directionDegree <= 204) {
        direction.textContent = 'S';
    } else if (directionDegree >= 205 && directionDegree <= 245) {
        direction.textContent = 'SW';
    } else if (directionDegree >= 246 && directionDegree <= 294) {
        direction.textContent = 'W';
    } else if (directionDegree >= 295 && directionDegree <= 335) {
        direction.textContent = 'NW';
    }

    windSpeed.textContent = systemType === 'metric' ? Math.round(locationData.current.windSpeed10m) : Math.round(locationData.current.windSpeed10m / 1.609344);
    gustSpeed.textContent = systemType === 'metric' ? Math.round(locationData.current.windGusts10m) : Math.round(locationData.current.windGusts10m / 1.609344);
};

const updatePressure = (locationData) => {
    (0,_pressureGauge__WEBPACK_IMPORTED_MODULE_12__["default"])(Math.round(locationData.current.pressureMsl));
};

function updateWeatherInfo(locationData, systemType) {
    updateBriefInfo(locationData, systemType);
    updateHourlyForecast(locationData, systemType);
    updateDailyForecast(locationData, systemType);
    updateFeelsLike(locationData, systemType);
    updateUvIndex(locationData);
    updateSunriseSunset(locationData);
    updateWind(locationData, systemType);
    updatePressure(locationData);
}


/***/ }),

/***/ "./src/modules/pressureGauge.js":
/*!**************************************!*\
  !*** ./src/modules/pressureGauge.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ pressureGauge)
/* harmony export */ });
/* harmony import */ var svg_gauge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svg-gauge */ "./node_modules/svg-gauge/index.js");
/* harmony import */ var svg_gauge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(svg_gauge__WEBPACK_IMPORTED_MODULE_0__);
// eslint-disable-next-line import/no-extraneous-dependencies


// Create a new Gauge
function pressureGauge(value) {
    svg_gauge__WEBPACK_IMPORTED_MODULE_0___default()(document.getElementById('gauge3'), {
        min: 975,
        max: 1050,
        label(_value) {
            return `${Math.round(_value)}`;
        },
        value,
        viewBox: '0 0 100 100',
    });
}


/***/ }),

/***/ "./src/modules/tempBar.js":
/*!********************************!*\
  !*** ./src/modules/tempBar.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createTempBarElement)
/* harmony export */ });
function createTempBarElement(_minTemp, _maxTemp) {
    const root = document.querySelector(':root');
    const vars = getComputedStyle(root);

    const slider = document.createElement('div');
    slider.classList.add('js-temp-bar');
    const progress = document.createElement('div');
    progress.classList.add('js-bar');

    let minTemp;
    let maxTemp;
    if (_minTemp >= 29) {
        minTemp = 29;
        maxTemp = 40;
        progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--90-perc')}, ${vars.getPropertyValue('--100-perc')}`;
    } else if (_minTemp >= 21) {
        minTemp = 21;
        if (_maxTemp > 33) {
            maxTemp = 39;
            progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--70-perc')}, ${vars.getPropertyValue('--80-perc')}, ${vars.getPropertyValue('--90-perc')}, ${vars.getPropertyValue('--100-perc')}`;
        } else {
            maxTemp = 33;
            progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--70-perc')}, ${vars.getPropertyValue('--80-perc')}, ${vars.getPropertyValue('--90-perc')}`;
        }
    } else if (_minTemp >= 10) {
        minTemp = 10;
        if (_maxTemp > 28) {
            maxTemp = 32;
            progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--50-perc')}, ${vars.getPropertyValue('--60-perc')}, ${vars.getPropertyValue('--70-perc')}, ${vars.getPropertyValue('--80-perc')}, ${vars.getPropertyValue('--90-perc')}`;
        } else {
            maxTemp = 28;
            progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--50-perc')}, ${vars.getPropertyValue('--60-perc')}, ${vars.getPropertyValue('--70-perc')}, ${vars.getPropertyValue('--80-perc')}`;
        }
    } else if (_minTemp <= 9) {
        minTemp = 0;
        if (_maxTemp > 15) {
            maxTemp = 27;
            progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--20-perc')}, ${vars.getPropertyValue('--30-perc')}, ${vars.getPropertyValue('--40-perc')}, ${vars.getPropertyValue('--50-perc')}, ${vars.getPropertyValue('--60-perc')}`;
        } else {
            maxTemp = 15;
            progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--20-perc')}, ${vars.getPropertyValue('--30-perc')}, ${vars.getPropertyValue('--40-perc')}, ${vars.getPropertyValue('--50-perc')}`;
        }
    } else if (_minTemp <= -1) {
        minTemp = -15;
        if (_maxTemp > 0) {
            maxTemp = 0;
            progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--0-perc')}, ${vars.getPropertyValue('--10-perc')}, ${vars.getPropertyValue('--20-perc')}, ${vars.getPropertyValue('--30-perc')}`;
        } else {
            maxTemp = -5;
            progress.style.background = `linear-gradient(90deg, ${vars.getPropertyValue('--0-perc')}, ${vars.getPropertyValue('--10-perc')}, ${vars.getPropertyValue('--20-perc')}`;
        }
    }

    const calculateLeftPercent = _minTemp <= minTemp
        ? 0
        : Math.round(((_minTemp - minTemp) * 100) / (maxTemp - minTemp));
    const calculateRightPercent = _maxTemp >= maxTemp
        ? 0
        : Math.round(100 - ((_maxTemp - minTemp) * 100) / (maxTemp - minTemp));

    progress.style.left = `${calculateLeftPercent}%`;
    progress.style.right = `${calculateRightPercent}%`;

    slider.append(progress);
    return slider;
}


/***/ }),

/***/ "./src/modules/timezoneFormatter.js":
/*!******************************************!*\
  !*** ./src/modules/timezoneFormatter.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatDateTimezone)
/* harmony export */ });
function formatDateTimezone(timezone, date = new Date()) {
    const optionsYear = {
        timeZone: timezone,
        year: 'numeric',
    };
    const formatterYear = new Intl.DateTimeFormat([], optionsYear);
    const newDateYear = formatterYear.format(date);

    const optionsMonth = {
        timeZone: timezone,
        month: '2-digit',
    };
    const formatterMonth = new Intl.DateTimeFormat([], optionsMonth);
    const newDateMonth = formatterMonth.format(date);

    const optionsDay = {
        timeZone: timezone,
        day: '2-digit',
    };
    const formatterDay = new Intl.DateTimeFormat([], optionsDay);
    const newDateDay = formatterDay.format(date);

    const optionsTime = {
        timeZone: timezone,
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: false,
    };
    const formatterTime = new Intl.DateTimeFormat([], optionsTime);
    const newDateTime = formatterTime.format(date);

    let newDate = `${newDateYear}/${newDateMonth}/${newDateDay}T${newDateTime}`;

    newDate = new Date(Date.parse(newDate.replaceAll('/', '-')));
    return newDate;
}


/***/ }),

/***/ "./src/modules/weather.js":
/*!********************************!*\
  !*** ./src/modules/weather.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLocationData)
/* harmony export */ });
/* harmony import */ var openmeteo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openmeteo */ "./node_modules/openmeteo/lib/index.js");
/* harmony import */ var openmeteo__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(openmeteo__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _timezoneFormatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timezoneFormatter */ "./src/modules/timezoneFormatter.js");
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-plusplus */



const range = __webpack_require__(/*! lodash.range */ "./node_modules/lodash.range/index.js");

const getCoords = async (location) => {
    try {
        const response = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${location}&count=1&language=en&format=json`, { mode: 'cors' });

        const data = await response.json();
        return data.results[0];
    } catch (err) {
        return err;
    }
};

const getSunriseSunset = async (location, timezone) => {
    try {
        let tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow = new Date(tomorrow.toLocaleString('en', { timeZone: timezone }));

        const responseToday = await fetch(`https://api.sunrise-sunset.org/json?lat=${location.latitude}&lng=${location.longitude}&date=today&tzid=${timezone}&formatted=0`, { mode: 'cors' });
        const responseTomorrow = await fetch(`https://api.sunrise-sunset.org/json?lat=${location.latitude}&lng=${location.longitude}&date=${tomorrow.getFullYear()}-${tomorrow.getMonth()}-${tomorrow.getDate()}&tzid=${timezone}&formatted=0`, { mode: 'cors' });

        const dataToday = await responseToday.json();
        const dataTomorrow = await responseTomorrow.json();

        return [dataToday.results, dataTomorrow.results];
    } catch (err) {
        return err;
    }
};

async function getLocationData(location) {
    const locationCoords = await getCoords(location);

    const params = {
        latitude: locationCoords.latitude,
        longitude: locationCoords.longitude,
        current: ['temperature_2m', 'relative_humidity_2m', 'apparent_temperature', 'precipitation', 'weather_code', 'is_day', 'wind_speed_10m', 'wind_direction_10m', 'wind_gusts_10m', 'pressure_msl'],
        hourly: ['temperature_2m', 'precipitation', 'weather_code', 'uv_index', 'is_day'],
        daily: ['weather_code', 'temperature_2m_max', 'temperature_2m_min', 'uv_index_max'],
        timezone: 'auto',
        past_days: 7,
        forecast_days: 14,
        forecast_hours: 24,
    };

    const url = 'https://api.open-meteo.com/v1/forecast';
    const responses = await (0,openmeteo__WEBPACK_IMPORTED_MODULE_0__.fetchWeatherApi)(url, params);

    // Process first location
    const response = responses[0];

    // Attributes for timezone and location
    const timezone = response.timezone();
    const current = response.current();
    const hourly = response.hourly();
    const daily = response.daily();

    // Get sunrise and sunset data
    const sunriseSunset = await getSunriseSunset(locationCoords, timezone);

    // Note: The order of weather variables in the URL query and the indices below need to match!
    const weatherData = {
        location: {
            name: locationCoords.name,
            timezone: locationCoords.timezone,
        },
        current: {
            time: (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_1__["default"])(timezone, new Date()),
            temperature2m: current.variables(0).value(),
            relativeHumidity2m: current.variables(1).value(),
            apparentTemperature: current.variables(2).value(),
            precipitation: current.variables(3).value(),
            weatherCode: current.variables(4).value(),
            isDay: current.variables(5).value(),
            windSpeed10m: current.variables(6).value(),
            windDirection10m: current.variables(7).value(),
            windGusts10m: current.variables(8).value(),
            pressureMsl: current.variables(9).value(),
        },
        hourly: {
            time: range(Number(hourly.time()), Number(hourly.timeEnd()), hourly.interval()).map(
                (t) => (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_1__["default"])(timezone, new Date(t * 1000)),
            ),
            temperature2m: hourly.variables(0).valuesArray(),
            precipitation: hourly.variables(1).valuesArray(),
            weatherCode: hourly.variables(2).valuesArray(),
            uvIndex: hourly.variables(3).valuesArray(),
            isDay: hourly.variables(4).valuesArray(),
        },
        daily: {
            time: range(Number(daily.time()), Number(daily.timeEnd()), daily.interval()).map(
                (t) => (0,_timezoneFormatter__WEBPACK_IMPORTED_MODULE_1__["default"])(timezone, new Date(t * 1000)),
            ),
            weatherCode: daily.variables(0).valuesArray(),
            temperature2mMax: daily.variables(1).valuesArray(),
            temperature2mMin: daily.variables(2).valuesArray(),
            uvIndexMax: daily.variables(3).valuesArray(),
            sunriseSunset,
        },

    };
    return weatherData;
}


/***/ }),

/***/ "./src/assets/icons/sunrise.svg":
/*!**************************************!*\
  !*** ./src/assets/icons/sunrise.svg ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "sunrise.svg";

/***/ }),

/***/ "./src/assets/icons/sunset.svg":
/*!*************************************!*\
  !*** ./src/assets/icons/sunset.svg ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "sunset.svg";

/***/ }),

/***/ "./src/assets/json/weatherCodes.json":
/*!*******************************************!*\
  !*** ./src/assets/json/weatherCodes.json ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"0":{"day":{"description":"Sunny","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/575900edccbc7def167f7874c02aeb0b.png"},"night":{"description":"Clear","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/1200cde3569cf69bd80e1ddabc0f15cd.png"}},"1":{"day":{"description":"Mainly Sunny","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/575900edccbc7def167f7874c02aeb0b.png"},"night":{"description":"Mainly Clear","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/1200cde3569cf69bd80e1ddabc0f15cd.png"}},"2":{"day":{"description":"Partly Cloudy","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/67aaf9dbe30989c25cbde6c6ec099213.png"},"night":{"description":"Partly Cloudy","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/17cc1a8a95028b89ba6988ee47eeab29.png"}},"3":{"day":{"description":"Cloudy","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/67aaf9dbe30989c25cbde6c6ec099213.png"},"night":{"description":"Cloudy","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/17cc1a8a95028b89ba6988ee47eeab29.png"}},"45":{"day":{"description":"Foggy","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d35bb25d12281cd9ee5ce78a98cd2aa7.png"},"night":{"description":"Foggy","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d35bb25d12281cd9ee5ce78a98cd2aa7.png"}},"48":{"day":{"description":"Rime Fog","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d35bb25d12281cd9ee5ce78a98cd2aa7.png"},"night":{"description":"Rime Fog","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d35bb25d12281cd9ee5ce78a98cd2aa7.png"}},"51":{"day":{"description":"Light Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/a55fef55bbeb0762a8dd329b4b8ad342.png"},"night":{"description":"Light Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d4b6596291c114305b64056bd92ccee3.png"}},"53":{"day":{"description":"Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/a55fef55bbeb0762a8dd329b4b8ad342.png"},"night":{"description":"Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d4b6596291c114305b64056bd92ccee3.png"}},"55":{"day":{"description":"Heavy Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/a55fef55bbeb0762a8dd329b4b8ad342.png"},"night":{"description":"Heavy Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d4b6596291c114305b64056bd92ccee3.png"}},"56":{"day":{"description":"Light Freezing Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/a55fef55bbeb0762a8dd329b4b8ad342.png"},"night":{"description":"Light Freezing Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d4b6596291c114305b64056bd92ccee3.png"}},"57":{"day":{"description":"Freezing Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/a55fef55bbeb0762a8dd329b4b8ad342.png"},"night":{"description":"Freezing Drizzle","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d4b6596291c114305b64056bd92ccee3.png"}},"61":{"day":{"description":"Light Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/a55fef55bbeb0762a8dd329b4b8ad342.png"},"night":{"description":"Light Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/d4b6596291c114305b64056bd92ccee3.png"}},"63":{"day":{"description":"Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/4417bf88c7bbcd8e24fb78ee6479b362.png"},"night":{"description":"Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/4417bf88c7bbcd8e24fb78ee6479b362.png"}},"65":{"day":{"description":"Heavy Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/451d37e6cea3af4a568110863a1adcf7.png"},"night":{"description":"Heavy Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/451d37e6cea3af4a568110863a1adcf7.png"}},"66":{"day":{"description":"Light Freezing Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/9189cb49e806d1ebfeed24f33367143c.png"},"night":{"description":"Light Freezing Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/9189cb49e806d1ebfeed24f33367143c.png"}},"67":{"day":{"description":"Freezing Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/9189cb49e806d1ebfeed24f33367143c.png"},"night":{"description":"Freezing Rain","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/9189cb49e806d1ebfeed24f33367143c.png"}},"71":{"day":{"description":"Light Snow","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/00171e3b54b97dee8c1a2f6a62272640.png"},"night":{"description":"Light Snow","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/00171e3b54b97dee8c1a2f6a62272640.png"}},"73":{"day":{"description":"Snow","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/00171e3b54b97dee8c1a2f6a62272640.png"},"night":{"description":"Snow","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/00171e3b54b97dee8c1a2f6a62272640.png"}},"75":{"day":{"description":"Heavy Snow","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/e95fb90fc5a4aac111be78770921beb1.png"},"night":{"description":"Heavy Snow","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/e95fb90fc5a4aac111be78770921beb1.png"}},"77":{"day":{"description":"Snow Grains","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/e95fb90fc5a4aac111be78770921beb1.png"},"night":{"description":"Snow Grains","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/e95fb90fc5a4aac111be78770921beb1.png"}},"80":{"day":{"description":"Light Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/a55fef55bbeb0762a8dd329b4b8ad342.png"},"night":{"description":"Light Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/a55fef55bbeb0762a8dd329b4b8ad342.png"}},"81":{"day":{"description":"Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/4417bf88c7bbcd8e24fb78ee6479b362.png"},"night":{"description":"Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/4417bf88c7bbcd8e24fb78ee6479b362.png"}},"82":{"day":{"description":"Heavy Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/451d37e6cea3af4a568110863a1adcf7.png"},"night":{"description":"Heavy Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/451d37e6cea3af4a568110863a1adcf7.png"}},"85":{"day":{"description":"Light Snow Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/9189cb49e806d1ebfeed24f33367143c.png"},"night":{"description":"Light Snow Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/9189cb49e806d1ebfeed24f33367143c.png"}},"86":{"day":{"description":"Snow Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/00171e3b54b97dee8c1a2f6a62272640.png"},"night":{"description":"Snow Showers","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/00171e3b54b97dee8c1a2f6a62272640.png"}},"95":{"day":{"description":"Thunderstorm","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/efffb1e26f6de5bf5c8adbd872a2933a.png"},"night":{"description":"Thunderstorm","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/efffb1e26f6de5bf5c8adbd872a2933a.png"}},"96":{"day":{"description":"Light Thunderstorms With Hail","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/efffb1e26f6de5bf5c8adbd872a2933a.png"},"night":{"description":"Light Thunderstorms With Hail","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/efffb1e26f6de5bf5c8adbd872a2933a.png"}},"99":{"day":{"description":"Thunderstorm With Hail","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/efffb1e26f6de5bf5c8adbd872a2933a.png"},"night":{"description":"Thunderstorm With Hail","image":"https://help.apple.com/assets/65E21662495F1A6C8701F50A/65E21663EF8273BE1D0C2734/en_US/efffb1e26f6de5bf5c8adbd872a2933a.png"}}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"index": 0,
/******/ 			"styles": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunktemplate"] = self["webpackChunktemplate"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["styles"], () => (__webpack_require__("./src/index.js")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQix1REFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsc0JBQXNCLFFBQVE7QUFDOUIscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSx1Q0FBdUMseURBQXlEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7Ozs7O1dDekJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsK0JBQStCLHdDQUF3QztXQUN2RTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlCQUFpQixxQkFBcUI7V0FDdEM7V0FDQTtXQUNBLGtCQUFrQixxQkFBcUI7V0FDdkM7V0FDQTtXQUNBLEtBQUs7V0FDTDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDM0JBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ2xCQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNLHFCQUFxQjtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTs7Ozs7VUVqREE7VUFDQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BvcGVubWV0ZW8vc2RrL2FnZ3JlZ2F0aW9uLmpzIiwid2VicGFjazovL3RlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BvcGVubWV0ZW8vc2RrL21vZGVsLmpzIiwid2VicGFjazovL3RlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BvcGVubWV0ZW8vc2RrL3VuaXQuanMiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9wZW5tZXRlby9zZGsvdmFyaWFibGUtd2l0aC12YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9wZW5tZXRlby9zZGsvdmFyaWFibGUuanMiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG9wZW5tZXRlby9zZGsvdmFyaWFibGVzLXdpdGgtdGltZS5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9Ab3Blbm1ldGVvL3Nkay93ZWF0aGVyLWFwaS1yZXNwb25zZS5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvYnVpbGRlci5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvYnl0ZS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvbWpzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvZW5jb2RpbmcuanMiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvbWpzL2ZsYXRidWZmZXJzLmpzIiwid2VicGFjazovL3RlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy91dGlscy5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9sb2Rhc2gucmFuZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzP2ZiNTciLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9zcmMvaW5kZXgtc3R5bGUuY3NzP2VhZWQiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9zcmMvc3R5bGVzL2RhaWx5LWZvcmVjYXN0LXN0eWxlLmNzcz9mY2JkIiwid2VicGFjazovL3RlbXBsYXRlLy4vc3JjL3N0eWxlcy9mZWVscy1saWtlLXN0eWxlLmNzcz8wNWZlIiwid2VicGFjazovL3RlbXBsYXRlLy4vc3JjL3N0eWxlcy9ob3VybHktZm9yZWNhc3Qtc3R5bGUuY3NzPzFmODAiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9zcmMvc3R5bGVzL3ByZXNzdXJlLXN0eWxlLmNzcz9hYTVjIiwid2VicGFjazovL3RlbXBsYXRlLy4vc3JjL3N0eWxlcy9zdW5yaXNlLXN1bnNldC1zdHlsZS5jc3M/NGJjMyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL3NyYy9zdHlsZXMvdXYtaW5kZXgtc3R5bGUuY3NzP2ZmOWQiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9zcmMvc3R5bGVzL3dpbmQtc3R5bGUuY3NzPzE5M2UiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvb3Blbm1ldGVvL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9zdmctZ2F1Z2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvc3ZnLWdhdWdlL3NyYy9nYXVnZS5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL3NyYy9tb2R1bGVzL2RvbUNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvLi9zcmMvbW9kdWxlcy9wcmVzc3VyZUdhdWdlLmpzIiwid2VicGFjazovL3RlbXBsYXRlLy4vc3JjL21vZHVsZXMvdGVtcEJhci5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS8uL3NyYy9tb2R1bGVzL3RpbWV6b25lRm9ybWF0dGVyLmpzIiwid2VicGFjazovL3RlbXBsYXRlLy4vc3JjL21vZHVsZXMvd2VhdGhlci5qcyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvY2h1bmsgbG9hZGVkIiwid2VicGFjazovL3RlbXBsYXRlL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3RlbXBsYXRlL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3RlbXBsYXRlL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdGVtcGxhdGUvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly90ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly90ZW1wbGF0ZS93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly90ZW1wbGF0ZS93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL3RlbXBsYXRlL3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly90ZW1wbGF0ZS93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSB0aGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIsIGRvIG5vdCBtb2RpZnlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWdncmVnYXRpb24gPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gKi9cbnZhciBBZ2dyZWdhdGlvbjtcbihmdW5jdGlvbiAoQWdncmVnYXRpb24pIHtcbiAgICBBZ2dyZWdhdGlvbltBZ2dyZWdhdGlvbltcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wibWluaW11bVwiXSA9IDFdID0gXCJtaW5pbXVtXCI7XG4gICAgQWdncmVnYXRpb25bQWdncmVnYXRpb25bXCJtYXhpbXVtXCJdID0gMl0gPSBcIm1heGltdW1cIjtcbiAgICBBZ2dyZWdhdGlvbltBZ2dyZWdhdGlvbltcIm1lYW5cIl0gPSAzXSA9IFwibWVhblwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wicDEwXCJdID0gNF0gPSBcInAxMFwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wicDI1XCJdID0gNV0gPSBcInAyNVwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wibWVkaWFuXCJdID0gNl0gPSBcIm1lZGlhblwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wicDc1XCJdID0gN10gPSBcInA3NVwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wicDkwXCJdID0gOF0gPSBcInA5MFwiO1xuICAgIEFnZ3JlZ2F0aW9uW0FnZ3JlZ2F0aW9uW1wiZG9taW5hbnRcIl0gPSA5XSA9IFwiZG9taW5hbnRcIjtcbiAgICBBZ2dyZWdhdGlvbltBZ2dyZWdhdGlvbltcInN1bVwiXSA9IDEwXSA9IFwic3VtXCI7XG59KShBZ2dyZWdhdGlvbiB8fCAoZXhwb3J0cy5BZ2dyZWdhdGlvbiA9IEFnZ3JlZ2F0aW9uID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgdGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyLCBkbyBub3QgbW9kaWZ5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1vZGVsID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG52YXIgTW9kZWw7XG4oZnVuY3Rpb24gKE1vZGVsKSB7XG4gICAgTW9kZWxbTW9kZWxbXCJ1bmRlZmluZWRcIl0gPSAwXSA9IFwidW5kZWZpbmVkXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJiZXN0X21hdGNoXCJdID0gMV0gPSBcImJlc3RfbWF0Y2hcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdmc19zZWFtbGVzc1wiXSA9IDJdID0gXCJnZnNfc2VhbWxlc3NcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdmc19nbG9iYWxcIl0gPSAzXSA9IFwiZ2ZzX2dsb2JhbFwiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2ZzX2hycnJcIl0gPSA0XSA9IFwiZ2ZzX2hycnJcIjtcbiAgICBNb2RlbFtNb2RlbFtcIm1ldGVvZnJhbmNlX3NlYW1sZXNzXCJdID0gNV0gPSBcIm1ldGVvZnJhbmNlX3NlYW1sZXNzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJtZXRlb2ZyYW5jZV9hcnBlZ2Vfc2VhbWxlc3NcIl0gPSA2XSA9IFwibWV0ZW9mcmFuY2VfYXJwZWdlX3NlYW1sZXNzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJtZXRlb2ZyYW5jZV9hcnBlZ2Vfd29ybGRcIl0gPSA3XSA9IFwibWV0ZW9mcmFuY2VfYXJwZWdlX3dvcmxkXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJtZXRlb2ZyYW5jZV9hcnBlZ2VfZXVyb3BlXCJdID0gOF0gPSBcIm1ldGVvZnJhbmNlX2FycGVnZV9ldXJvcGVcIjtcbiAgICBNb2RlbFtNb2RlbFtcIm1ldGVvZnJhbmNlX2Fyb21lX3NlYW1sZXNzXCJdID0gOV0gPSBcIm1ldGVvZnJhbmNlX2Fyb21lX3NlYW1sZXNzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJtZXRlb2ZyYW5jZV9hcm9tZV9mcmFuY2VcIl0gPSAxMF0gPSBcIm1ldGVvZnJhbmNlX2Fyb21lX2ZyYW5jZVwiO1xuICAgIE1vZGVsW01vZGVsW1wibWV0ZW9mcmFuY2VfYXJvbWVfZnJhbmNlX2hkXCJdID0gMTFdID0gXCJtZXRlb2ZyYW5jZV9hcm9tZV9mcmFuY2VfaGRcIjtcbiAgICBNb2RlbFtNb2RlbFtcImptYV9zZWFtbGVzc1wiXSA9IDEyXSA9IFwiam1hX3NlYW1sZXNzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJqbWFfbXNtXCJdID0gMTNdID0gXCJqbWFfbXNtXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJqbXNfZ3NtXCJdID0gMTRdID0gXCJqbXNfZ3NtXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJqbWFfZ3NtXCJdID0gMTVdID0gXCJqbWFfZ3NtXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnZW1fc2VhbWxlc3NcIl0gPSAxNl0gPSBcImdlbV9zZWFtbGVzc1wiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2VtX2dsb2JhbFwiXSA9IDE3XSA9IFwiZ2VtX2dsb2JhbFwiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2VtX3JlZ2lvbmFsXCJdID0gMThdID0gXCJnZW1fcmVnaW9uYWxcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdlbV9ocmRwc19jb250aW5lbnRhbFwiXSA9IDE5XSA9IFwiZ2VtX2hyZHBzX2NvbnRpbmVudGFsXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJpY29uX3NlYW1sZXNzXCJdID0gMjBdID0gXCJpY29uX3NlYW1sZXNzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJpY29uX2dsb2JhbFwiXSA9IDIxXSA9IFwiaWNvbl9nbG9iYWxcIjtcbiAgICBNb2RlbFtNb2RlbFtcImljb25fZXVcIl0gPSAyMl0gPSBcImljb25fZXVcIjtcbiAgICBNb2RlbFtNb2RlbFtcImljb25fZDJcIl0gPSAyM10gPSBcImljb25fZDJcIjtcbiAgICBNb2RlbFtNb2RlbFtcImVjbXdmX2lmczA0XCJdID0gMjRdID0gXCJlY213Zl9pZnMwNFwiO1xuICAgIE1vZGVsW01vZGVsW1wibWV0bm9fbm9yZGljXCJdID0gMjVdID0gXCJtZXRub19ub3JkaWNcIjtcbiAgICBNb2RlbFtNb2RlbFtcImVyYTVfc2VhbWxlc3NcIl0gPSAyNl0gPSBcImVyYTVfc2VhbWxlc3NcIjtcbiAgICBNb2RlbFtNb2RlbFtcImVyYTVcIl0gPSAyN10gPSBcImVyYTVcIjtcbiAgICBNb2RlbFtNb2RlbFtcImNlcnJhXCJdID0gMjhdID0gXCJjZXJyYVwiO1xuICAgIE1vZGVsW01vZGVsW1wiZXJhNV9sYW5kXCJdID0gMjldID0gXCJlcmE1X2xhbmRcIjtcbiAgICBNb2RlbFtNb2RlbFtcImVjbXdmX2lmc1wiXSA9IDMwXSA9IFwiZWNtd2ZfaWZzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnd2FtXCJdID0gMzFdID0gXCJnd2FtXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJld2FtXCJdID0gMzJdID0gXCJld2FtXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnbG9mYXNfc2VhbWxlc3NfdjNcIl0gPSAzM10gPSBcImdsb2Zhc19zZWFtbGVzc192M1wiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2xvZmFzX2ZvcmVjYXN0X3YzXCJdID0gMzRdID0gXCJnbG9mYXNfZm9yZWNhc3RfdjNcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdsb2Zhc19jb25zb2xpZGF0ZWRfdjNcIl0gPSAzNV0gPSBcImdsb2Zhc19jb25zb2xpZGF0ZWRfdjNcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdsb2Zhc19zZWFtbGVzc192NFwiXSA9IDM2XSA9IFwiZ2xvZmFzX3NlYW1sZXNzX3Y0XCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnbG9mYXNfZm9yZWNhc3RfdjRcIl0gPSAzN10gPSBcImdsb2Zhc19mb3JlY2FzdF92NFwiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2xvZmFzX2NvbnNvbGlkYXRlZF92NFwiXSA9IDM4XSA9IFwiZ2xvZmFzX2NvbnNvbGlkYXRlZF92NFwiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2ZzMDI1XCJdID0gMzldID0gXCJnZnMwMjVcIjtcbiAgICBNb2RlbFtNb2RlbFtcImdmczA1XCJdID0gNDBdID0gXCJnZnMwNVwiO1xuICAgIE1vZGVsW01vZGVsW1wiQ01DQ19DTTJfVkhSNFwiXSA9IDQxXSA9IFwiQ01DQ19DTTJfVkhSNFwiO1xuICAgIE1vZGVsW01vZGVsW1wiRkdPQUxTX2YzX0hfaGlnaHJlc1NTVFwiXSA9IDQyXSA9IFwiRkdPQUxTX2YzX0hfaGlnaHJlc1NTVFwiO1xuICAgIE1vZGVsW01vZGVsW1wiRkdPQUxTX2YzX0hcIl0gPSA0M10gPSBcIkZHT0FMU19mM19IXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJIaVJBTV9TSVRfSFJcIl0gPSA0NF0gPSBcIkhpUkFNX1NJVF9IUlwiO1xuICAgIE1vZGVsW01vZGVsW1wiTVJJX0FHQ00zXzJfU1wiXSA9IDQ1XSA9IFwiTVJJX0FHQ00zXzJfU1wiO1xuICAgIE1vZGVsW01vZGVsW1wiRUNfRWFydGgzUF9IUlwiXSA9IDQ2XSA9IFwiRUNfRWFydGgzUF9IUlwiO1xuICAgIE1vZGVsW01vZGVsW1wiTVBJX0VTTTFfMl9YUlwiXSA9IDQ3XSA9IFwiTVBJX0VTTTFfMl9YUlwiO1xuICAgIE1vZGVsW01vZGVsW1wiTklDQU0xNl84U1wiXSA9IDQ4XSA9IFwiTklDQU0xNl84U1wiO1xuICAgIE1vZGVsW01vZGVsW1wiY2Ftc19ldXJvcGVcIl0gPSA0OV0gPSBcImNhbXNfZXVyb3BlXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJjYW1zX2dsb2JhbFwiXSA9IDUwXSA9IFwiY2Ftc19nbG9iYWxcIjtcbiAgICBNb2RlbFtNb2RlbFtcImNmc3YyXCJdID0gNTFdID0gXCJjZnN2MlwiO1xuICAgIE1vZGVsW01vZGVsW1wiZXJhNV9vY2VhblwiXSA9IDUyXSA9IFwiZXJhNV9vY2VhblwiO1xuICAgIE1vZGVsW01vZGVsW1wiY21hX2dyYXBlc19nbG9iYWxcIl0gPSA1M10gPSBcImNtYV9ncmFwZXNfZ2xvYmFsXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJib21fYWNjZXNzX2dsb2JhbFwiXSA9IDU0XSA9IFwiYm9tX2FjY2Vzc19nbG9iYWxcIjtcbiAgICBNb2RlbFtNb2RlbFtcImJvbV9hY2Nlc3NfZ2xvYmFsX2Vuc2VtYmxlXCJdID0gNTVdID0gXCJib21fYWNjZXNzX2dsb2JhbF9lbnNlbWJsZVwiO1xuICAgIE1vZGVsW01vZGVsW1wiYXJwYWVfY29zbW9fc2VhbWxlc3NcIl0gPSA1Nl0gPSBcImFycGFlX2Nvc21vX3NlYW1sZXNzXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJhcnBhZV9jb3Ntb18yaVwiXSA9IDU3XSA9IFwiYXJwYWVfY29zbW9fMmlcIjtcbiAgICBNb2RlbFtNb2RlbFtcImFycGFlX2Nvc21vXzJpX3J1Y1wiXSA9IDU4XSA9IFwiYXJwYWVfY29zbW9fMmlfcnVjXCI7XG4gICAgTW9kZWxbTW9kZWxbXCJhcnBhZV9jb3Ntb181bVwiXSA9IDU5XSA9IFwiYXJwYWVfY29zbW9fNW1cIjtcbiAgICBNb2RlbFtNb2RlbFtcImVjbXdmX2lmczAyNVwiXSA9IDYwXSA9IFwiZWNtd2ZfaWZzMDI1XCI7XG4gICAgTW9kZWxbTW9kZWxbXCJlY213Zl9haWZzMDI1XCJdID0gNjFdID0gXCJlY213Zl9haWZzMDI1XCI7XG4gICAgTW9kZWxbTW9kZWxbXCJnZnMwMTNcIl0gPSA2Ml0gPSBcImdmczAxM1wiO1xuICAgIE1vZGVsW01vZGVsW1wiZ2ZzX2dyYXBoY2FzdDAyNVwiXSA9IDYzXSA9IFwiZ2ZzX2dyYXBoY2FzdDAyNVwiO1xuICAgIE1vZGVsW01vZGVsW1wiZWNtd2Zfd2FtMDI1XCJdID0gNjRdID0gXCJlY213Zl93YW0wMjVcIjtcbiAgICBNb2RlbFtNb2RlbFtcIm1ldGVvZnJhbmNlX3dhdmVcIl0gPSA2NV0gPSBcIm1ldGVvZnJhbmNlX3dhdmVcIjtcbiAgICBNb2RlbFtNb2RlbFtcIm1ldGVvZnJhbmNlX2N1cnJlbnRzXCJdID0gNjZdID0gXCJtZXRlb2ZyYW5jZV9jdXJyZW50c1wiO1xufSkoTW9kZWwgfHwgKGV4cG9ydHMuTW9kZWwgPSBNb2RlbCA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Vbml0ID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG52YXIgVW5pdDtcbihmdW5jdGlvbiAoVW5pdCkge1xuICAgIFVuaXRbVW5pdFtcInVuZGVmaW5lZFwiXSA9IDBdID0gXCJ1bmRlZmluZWRcIjtcbiAgICBVbml0W1VuaXRbXCJjZWxzaXVzXCJdID0gMV0gPSBcImNlbHNpdXNcIjtcbiAgICBVbml0W1VuaXRbXCJjZW50aW1ldHJlXCJdID0gMl0gPSBcImNlbnRpbWV0cmVcIjtcbiAgICBVbml0W1VuaXRbXCJjdWJpY19tZXRyZV9wZXJfY3ViaWNfbWV0cmVcIl0gPSAzXSA9IFwiY3ViaWNfbWV0cmVfcGVyX2N1YmljX21ldHJlXCI7XG4gICAgVW5pdFtVbml0W1wiY3ViaWNfbWV0cmVfcGVyX3NlY29uZFwiXSA9IDRdID0gXCJjdWJpY19tZXRyZV9wZXJfc2Vjb25kXCI7XG4gICAgVW5pdFtVbml0W1wiZGVncmVlX2RpcmVjdGlvblwiXSA9IDVdID0gXCJkZWdyZWVfZGlyZWN0aW9uXCI7XG4gICAgVW5pdFtVbml0W1wiZGltZW5zaW9ubGVzc19pbnRlZ2VyXCJdID0gNl0gPSBcImRpbWVuc2lvbmxlc3NfaW50ZWdlclwiO1xuICAgIFVuaXRbVW5pdFtcImRpbWVuc2lvbmxlc3NcIl0gPSA3XSA9IFwiZGltZW5zaW9ubGVzc1wiO1xuICAgIFVuaXRbVW5pdFtcImV1cm9wZWFuX2Fpcl9xdWFsaXR5X2luZGV4XCJdID0gOF0gPSBcImV1cm9wZWFuX2Fpcl9xdWFsaXR5X2luZGV4XCI7XG4gICAgVW5pdFtVbml0W1wiZmFocmVuaGVpdFwiXSA9IDldID0gXCJmYWhyZW5oZWl0XCI7XG4gICAgVW5pdFtVbml0W1wiZmVldFwiXSA9IDEwXSA9IFwiZmVldFwiO1xuICAgIFVuaXRbVW5pdFtcImZyYWN0aW9uXCJdID0gMTFdID0gXCJmcmFjdGlvblwiO1xuICAgIFVuaXRbVW5pdFtcImdkZF9jZWxzaXVzXCJdID0gMTJdID0gXCJnZGRfY2Vsc2l1c1wiO1xuICAgIFVuaXRbVW5pdFtcImdlb3BvdGVudGlhbF9tZXRyZVwiXSA9IDEzXSA9IFwiZ2VvcG90ZW50aWFsX21ldHJlXCI7XG4gICAgVW5pdFtVbml0W1wiZ3JhaW5zX3Blcl9jdWJpY19tZXRyZVwiXSA9IDE0XSA9IFwiZ3JhaW5zX3Blcl9jdWJpY19tZXRyZVwiO1xuICAgIFVuaXRbVW5pdFtcImdyYW1fcGVyX2tpbG9ncmFtXCJdID0gMTVdID0gXCJncmFtX3Blcl9raWxvZ3JhbVwiO1xuICAgIFVuaXRbVW5pdFtcImhlY3RvcGFzY2FsXCJdID0gMTZdID0gXCJoZWN0b3Bhc2NhbFwiO1xuICAgIFVuaXRbVW5pdFtcImhvdXJzXCJdID0gMTddID0gXCJob3Vyc1wiO1xuICAgIFVuaXRbVW5pdFtcImluY2hcIl0gPSAxOF0gPSBcImluY2hcIjtcbiAgICBVbml0W1VuaXRbXCJpc284NjAxXCJdID0gMTldID0gXCJpc284NjAxXCI7XG4gICAgVW5pdFtVbml0W1wiam91bGVfcGVyX2tpbG9ncmFtXCJdID0gMjBdID0gXCJqb3VsZV9wZXJfa2lsb2dyYW1cIjtcbiAgICBVbml0W1VuaXRbXCJrZWx2aW5cIl0gPSAyMV0gPSBcImtlbHZpblwiO1xuICAgIFVuaXRbVW5pdFtcImtpbG9wYXNjYWxcIl0gPSAyMl0gPSBcImtpbG9wYXNjYWxcIjtcbiAgICBVbml0W1VuaXRbXCJraWxvZ3JhbV9wZXJfc3F1YXJlX21ldHJlXCJdID0gMjNdID0gXCJraWxvZ3JhbV9wZXJfc3F1YXJlX21ldHJlXCI7XG4gICAgVW5pdFtVbml0W1wia2lsb21ldHJlc19wZXJfaG91clwiXSA9IDI0XSA9IFwia2lsb21ldHJlc19wZXJfaG91clwiO1xuICAgIFVuaXRbVW5pdFtcImtub3RzXCJdID0gMjVdID0gXCJrbm90c1wiO1xuICAgIFVuaXRbVW5pdFtcIm1lZ2Fqb3VsZV9wZXJfc3F1YXJlX21ldHJlXCJdID0gMjZdID0gXCJtZWdham91bGVfcGVyX3NxdWFyZV9tZXRyZVwiO1xuICAgIFVuaXRbVW5pdFtcIm1ldHJlX3Blcl9zZWNvbmRfbm90X3VuaXRfY29udmVydGVkXCJdID0gMjddID0gXCJtZXRyZV9wZXJfc2Vjb25kX25vdF91bml0X2NvbnZlcnRlZFwiO1xuICAgIFVuaXRbVW5pdFtcIm1ldHJlX3Blcl9zZWNvbmRcIl0gPSAyOF0gPSBcIm1ldHJlX3Blcl9zZWNvbmRcIjtcbiAgICBVbml0W1VuaXRbXCJtZXRyZVwiXSA9IDI5XSA9IFwibWV0cmVcIjtcbiAgICBVbml0W1VuaXRbXCJtaWNyb2dyYW1zX3Blcl9jdWJpY19tZXRyZVwiXSA9IDMwXSA9IFwibWljcm9ncmFtc19wZXJfY3ViaWNfbWV0cmVcIjtcbiAgICBVbml0W1VuaXRbXCJtaWxlc19wZXJfaG91clwiXSA9IDMxXSA9IFwibWlsZXNfcGVyX2hvdXJcIjtcbiAgICBVbml0W1VuaXRbXCJtaWxsaW1ldHJlXCJdID0gMzJdID0gXCJtaWxsaW1ldHJlXCI7XG4gICAgVW5pdFtVbml0W1wicGFzY2FsXCJdID0gMzNdID0gXCJwYXNjYWxcIjtcbiAgICBVbml0W1VuaXRbXCJwZXJfc2Vjb25kXCJdID0gMzRdID0gXCJwZXJfc2Vjb25kXCI7XG4gICAgVW5pdFtVbml0W1wicGVyY2VudGFnZVwiXSA9IDM1XSA9IFwicGVyY2VudGFnZVwiO1xuICAgIFVuaXRbVW5pdFtcInNlY29uZHNcIl0gPSAzNl0gPSBcInNlY29uZHNcIjtcbiAgICBVbml0W1VuaXRbXCJ1bml4X3RpbWVcIl0gPSAzN10gPSBcInVuaXhfdGltZVwiO1xuICAgIFVuaXRbVW5pdFtcInVzX2Fpcl9xdWFsaXR5X2luZGV4XCJdID0gMzhdID0gXCJ1c19haXJfcXVhbGl0eV9pbmRleFwiO1xuICAgIFVuaXRbVW5pdFtcIndhdHRfcGVyX3NxdWFyZV9tZXRyZVwiXSA9IDM5XSA9IFwid2F0dF9wZXJfc3F1YXJlX21ldHJlXCI7XG4gICAgVW5pdFtVbml0W1wid21vX2NvZGVcIl0gPSA0MF0gPSBcIndtb19jb2RlXCI7XG59KShVbml0IHx8IChleHBvcnRzLlVuaXQgPSBVbml0ID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgdGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyLCBkbyBub3QgbW9kaWZ5XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFyaWFibGVXaXRoVmFsdWVzID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG5jb25zdCBmbGF0YnVmZmVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZmxhdGJ1ZmZlcnNcIikpO1xuY29uc3QgYWdncmVnYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuL2FnZ3JlZ2F0aW9uLmpzXCIpO1xuY29uc3QgdW5pdF9qc18xID0gcmVxdWlyZShcIi4vdW5pdC5qc1wiKTtcbmNvbnN0IHZhcmlhYmxlX2pzXzEgPSByZXF1aXJlKFwiLi92YXJpYWJsZS5qc1wiKTtcbmNsYXNzIFZhcmlhYmxlV2l0aFZhbHVlcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmIgPSBudWxsO1xuICAgICAgICB0aGlzLmJiX3BvcyA9IDA7XG4gICAgfVxuICAgIF9faW5pdChpLCBiYikge1xuICAgICAgICB0aGlzLmJiX3BvcyA9IGk7XG4gICAgICAgIHRoaXMuYmIgPSBiYjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRSb290QXNWYXJpYWJsZVdpdGhWYWx1ZXMoYmIsIG9iaikge1xuICAgICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFyaWFibGVXaXRoVmFsdWVzKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaXplUHJlZml4ZWRSb290QXNWYXJpYWJsZVdpdGhWYWx1ZXMoYmIsIG9iaikge1xuICAgICAgICBiYi5zZXRQb3NpdGlvbihiYi5wb3NpdGlvbigpICsgZmxhdGJ1ZmZlcnMuU0laRV9QUkVGSVhfTEVOR1RIKTtcbiAgICAgICAgcmV0dXJuIChvYmogfHwgbmV3IFZhcmlhYmxlV2l0aFZhbHVlcygpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cbiAgICB2YXJpYWJsZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgNCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB2YXJpYWJsZV9qc18xLlZhcmlhYmxlLnVuZGVmaW5lZDtcbiAgICB9XG4gICAgdW5pdCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgNik7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRVaW50OCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiB1bml0X2pzXzEuVW5pdC51bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA4KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMC4wO1xuICAgIH1cbiAgICB2YWx1ZXMoaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMTApO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkRmxvYXQzMih0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogNCkgOiAwO1xuICAgIH1cbiAgICB2YWx1ZXNMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuICAgIHZhbHVlc0FycmF5KCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYmIuYnl0ZXMoKS5idWZmZXIsIHRoaXMuYmIuYnl0ZXMoKS5ieXRlT2Zmc2V0ICsgdGhpcy5iYi5fX3ZlY3Rvcih0aGlzLmJiX3BvcyArIG9mZnNldCksIHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSkgOiBudWxsO1xuICAgIH1cbiAgICB2YWx1ZXNJbnQ2NChpbmRleCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiLl9fdmVjdG9yKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSArIGluZGV4ICogOCkgOiBCaWdJbnQoMCk7XG4gICAgfVxuICAgIHZhbHVlc0ludDY0TGVuZ3RoKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLl9fdmVjdG9yX2xlbih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cbiAgICBhbHRpdHVkZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMTQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkSW50MTYodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG4gICAgYWdncmVnYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE2KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZFVpbnQ4KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IGFnZ3JlZ2F0aW9uX2pzXzEuQWdncmVnYXRpb24ubm9uZTtcbiAgICB9XG4gICAgcHJlc3N1cmVMZXZlbCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMTgpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkSW50MTYodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG4gICAgZGVwdGgoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIwKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEludDE2KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuICAgIGRlcHRoVG8oKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEludDE2KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxuICAgIGVuc2VtYmxlTWVtYmVyKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyNCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQxNih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cbiAgICBwcmV2aW91c0RheSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkSW50MTYodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMDtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlV2l0aFZhbHVlcyA9IFZhcmlhYmxlV2l0aFZhbHVlcztcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgdGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyLCBkbyBub3QgbW9kaWZ5XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG52YXIgVmFyaWFibGU7XG4oZnVuY3Rpb24gKFZhcmlhYmxlKSB7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ1bmRlZmluZWRcIl0gPSAwXSA9IFwidW5kZWZpbmVkXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJhcHBhcmVudF90ZW1wZXJhdHVyZVwiXSA9IDFdID0gXCJhcHBhcmVudF90ZW1wZXJhdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiY2FwZVwiXSA9IDJdID0gXCJjYXBlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJjbG91ZF9jb3ZlclwiXSA9IDNdID0gXCJjbG91ZF9jb3ZlclwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiY2xvdWRfY292ZXJfaGlnaFwiXSA9IDRdID0gXCJjbG91ZF9jb3Zlcl9oaWdoXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJjbG91ZF9jb3Zlcl9sb3dcIl0gPSA1XSA9IFwiY2xvdWRfY292ZXJfbG93XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJjbG91ZF9jb3Zlcl9taWRcIl0gPSA2XSA9IFwiY2xvdWRfY292ZXJfbWlkXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJkYXlsaWdodF9kdXJhdGlvblwiXSA9IDddID0gXCJkYXlsaWdodF9kdXJhdGlvblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZGV3X3BvaW50XCJdID0gOF0gPSBcImRld19wb2ludFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZGlmZnVzZV9yYWRpYXRpb25cIl0gPSA5XSA9IFwiZGlmZnVzZV9yYWRpYXRpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImRpZmZ1c2VfcmFkaWF0aW9uX2luc3RhbnRcIl0gPSAxMF0gPSBcImRpZmZ1c2VfcmFkaWF0aW9uX2luc3RhbnRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImRpcmVjdF9ub3JtYWxfaXJyYWRpYW5jZVwiXSA9IDExXSA9IFwiZGlyZWN0X25vcm1hbF9pcnJhZGlhbmNlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJkaXJlY3Rfbm9ybWFsX2lycmFkaWFuY2VfaW5zdGFudFwiXSA9IDEyXSA9IFwiZGlyZWN0X25vcm1hbF9pcnJhZGlhbmNlX2luc3RhbnRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImRpcmVjdF9yYWRpYXRpb25cIl0gPSAxM10gPSBcImRpcmVjdF9yYWRpYXRpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImRpcmVjdF9yYWRpYXRpb25faW5zdGFudFwiXSA9IDE0XSA9IFwiZGlyZWN0X3JhZGlhdGlvbl9pbnN0YW50XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJldDBfZmFvX2V2YXBvdHJhbnNwaXJhdGlvblwiXSA9IDE1XSA9IFwiZXQwX2Zhb19ldmFwb3RyYW5zcGlyYXRpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImV2YXBvdHJhbnNwaXJhdGlvblwiXSA9IDE2XSA9IFwiZXZhcG90cmFuc3BpcmF0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJmcmVlemluZ19sZXZlbF9oZWlnaHRcIl0gPSAxN10gPSBcImZyZWV6aW5nX2xldmVsX2hlaWdodFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZ3Jvd2luZ19kZWdyZWVfZGF5c1wiXSA9IDE4XSA9IFwiZ3Jvd2luZ19kZWdyZWVfZGF5c1wiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiaXNfZGF5XCJdID0gMTldID0gXCJpc19kYXlcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImxhdGVudF9oZWF0X2ZsdXhcIl0gPSAyMF0gPSBcImxhdGVudF9oZWF0X2ZsdXhcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImxlYWZfd2V0bmVzc19wcm9iYWJpbGl0eVwiXSA9IDIxXSA9IFwibGVhZl93ZXRuZXNzX3Byb2JhYmlsaXR5XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJsaWZ0ZWRfaW5kZXhcIl0gPSAyMl0gPSBcImxpZnRlZF9pbmRleFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wibGlnaHRuaW5nX3BvdGVudGlhbFwiXSA9IDIzXSA9IFwibGlnaHRuaW5nX3BvdGVudGlhbFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicHJlY2lwaXRhdGlvblwiXSA9IDI0XSA9IFwicHJlY2lwaXRhdGlvblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicHJlY2lwaXRhdGlvbl9ob3Vyc1wiXSA9IDI1XSA9IFwicHJlY2lwaXRhdGlvbl9ob3Vyc1wiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicHJlY2lwaXRhdGlvbl9wcm9iYWJpbGl0eVwiXSA9IDI2XSA9IFwicHJlY2lwaXRhdGlvbl9wcm9iYWJpbGl0eVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicHJlc3N1cmVfbXNsXCJdID0gMjddID0gXCJwcmVzc3VyZV9tc2xcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInJhaW5cIl0gPSAyOF0gPSBcInJhaW5cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInJlbGF0aXZlX2h1bWlkaXR5XCJdID0gMjldID0gXCJyZWxhdGl2ZV9odW1pZGl0eVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicnVub2ZmXCJdID0gMzBdID0gXCJydW5vZmZcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInNlbnNpYmxlX2hlYXRfZmx1eFwiXSA9IDMxXSA9IFwic2Vuc2libGVfaGVhdF9mbHV4XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzaG9ydHdhdmVfcmFkaWF0aW9uXCJdID0gMzJdID0gXCJzaG9ydHdhdmVfcmFkaWF0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzaG9ydHdhdmVfcmFkaWF0aW9uX2luc3RhbnRcIl0gPSAzM10gPSBcInNob3J0d2F2ZV9yYWRpYXRpb25faW5zdGFudFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic2hvd2Vyc1wiXSA9IDM0XSA9IFwic2hvd2Vyc1wiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic25vd19kZXB0aFwiXSA9IDM1XSA9IFwic25vd19kZXB0aFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic25vd19oZWlnaHRcIl0gPSAzNl0gPSBcInNub3dfaGVpZ2h0XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzbm93ZmFsbFwiXSA9IDM3XSA9IFwic25vd2ZhbGxcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInNub3dmYWxsX2hlaWdodFwiXSA9IDM4XSA9IFwic25vd2ZhbGxfaGVpZ2h0XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzbm93ZmFsbF93YXRlcl9lcXVpdmFsZW50XCJdID0gMzldID0gXCJzbm93ZmFsbF93YXRlcl9lcXVpdmFsZW50XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzdW5yaXNlXCJdID0gNDBdID0gXCJzdW5yaXNlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzdW5zZXRcIl0gPSA0MV0gPSBcInN1bnNldFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic29pbF9tb2lzdHVyZVwiXSA9IDQyXSA9IFwic29pbF9tb2lzdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic29pbF9tb2lzdHVyZV9pbmRleFwiXSA9IDQzXSA9IFwic29pbF9tb2lzdHVyZV9pbmRleFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic29pbF90ZW1wZXJhdHVyZVwiXSA9IDQ0XSA9IFwic29pbF90ZW1wZXJhdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic3VyZmFjZV9wcmVzc3VyZVwiXSA9IDQ1XSA9IFwic3VyZmFjZV9wcmVzc3VyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic3VyZmFjZV90ZW1wZXJhdHVyZVwiXSA9IDQ2XSA9IFwic3VyZmFjZV90ZW1wZXJhdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widGVtcGVyYXR1cmVcIl0gPSA0N10gPSBcInRlbXBlcmF0dXJlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ0ZXJyZXN0cmlhbF9yYWRpYXRpb25cIl0gPSA0OF0gPSBcInRlcnJlc3RyaWFsX3JhZGlhdGlvblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widGVycmVzdHJpYWxfcmFkaWF0aW9uX2luc3RhbnRcIl0gPSA0OV0gPSBcInRlcnJlc3RyaWFsX3JhZGlhdGlvbl9pbnN0YW50XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ0b3RhbF9jb2x1bW5faW50ZWdyYXRlZF93YXRlcl92YXBvdXJcIl0gPSA1MF0gPSBcInRvdGFsX2NvbHVtbl9pbnRlZ3JhdGVkX3dhdGVyX3ZhcG91clwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXBkcmFmdFwiXSA9IDUxXSA9IFwidXBkcmFmdFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXZfaW5kZXhcIl0gPSA1Ml0gPSBcInV2X2luZGV4XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ1dl9pbmRleF9jbGVhcl9za3lcIl0gPSA1M10gPSBcInV2X2luZGV4X2NsZWFyX3NreVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widmFwb3VyX3ByZXNzdXJlX2RlZmljaXRcIl0gPSA1NF0gPSBcInZhcG91cl9wcmVzc3VyZV9kZWZpY2l0XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ2aXNpYmlsaXR5XCJdID0gNTVdID0gXCJ2aXNpYmlsaXR5XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3ZWF0aGVyX2NvZGVcIl0gPSA1Nl0gPSBcIndlYXRoZXJfY29kZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wid2luZF9kaXJlY3Rpb25cIl0gPSA1N10gPSBcIndpbmRfZGlyZWN0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3aW5kX2d1c3RzXCJdID0gNThdID0gXCJ3aW5kX2d1c3RzXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3aW5kX3NwZWVkXCJdID0gNTldID0gXCJ3aW5kX3NwZWVkXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ2ZXJ0aWNhbF92ZWxvY2l0eVwiXSA9IDYwXSA9IFwidmVydGljYWxfdmVsb2NpdHlcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImdlb3BvdGVudGlhbF9oZWlnaHRcIl0gPSA2MV0gPSBcImdlb3BvdGVudGlhbF9oZWlnaHRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndldF9idWxiX3RlbXBlcmF0dXJlXCJdID0gNjJdID0gXCJ3ZXRfYnVsYl90ZW1wZXJhdHVyZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicml2ZXJfZGlzY2hhcmdlXCJdID0gNjNdID0gXCJyaXZlcl9kaXNjaGFyZ2VcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndhdmVfaGVpZ2h0XCJdID0gNjRdID0gXCJ3YXZlX2hlaWdodFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wid2F2ZV9wZXJpb2RcIl0gPSA2NV0gPSBcIndhdmVfcGVyaW9kXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3YXZlX2RpcmVjdGlvblwiXSA9IDY2XSA9IFwid2F2ZV9kaXJlY3Rpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndpbmRfd2F2ZV9oZWlnaHRcIl0gPSA2N10gPSBcIndpbmRfd2F2ZV9oZWlnaHRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndpbmRfd2F2ZV9wZXJpb2RcIl0gPSA2OF0gPSBcIndpbmRfd2F2ZV9wZXJpb2RcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcIndpbmRfd2F2ZV9wZWFrX3BlcmlvZFwiXSA9IDY5XSA9IFwid2luZF93YXZlX3BlYWtfcGVyaW9kXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ3aW5kX3dhdmVfZGlyZWN0aW9uXCJdID0gNzBdID0gXCJ3aW5kX3dhdmVfZGlyZWN0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzd2VsbF93YXZlX2hlaWdodFwiXSA9IDcxXSA9IFwic3dlbGxfd2F2ZV9oZWlnaHRcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInN3ZWxsX3dhdmVfcGVyaW9kXCJdID0gNzJdID0gXCJzd2VsbF93YXZlX3BlcmlvZFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic3dlbGxfd2F2ZV9wZWFrX3BlcmlvZFwiXSA9IDczXSA9IFwic3dlbGxfd2F2ZV9wZWFrX3BlcmlvZFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic3dlbGxfd2F2ZV9kaXJlY3Rpb25cIl0gPSA3NF0gPSBcInN3ZWxsX3dhdmVfZGlyZWN0aW9uXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJwbTEwXCJdID0gNzVdID0gXCJwbTEwXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJwbTJwNVwiXSA9IDc2XSA9IFwicG0ycDVcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImR1c3RcIl0gPSA3N10gPSBcImR1c3RcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImFlcm9zb2xfb3B0aWNhbF9kZXB0aFwiXSA9IDc4XSA9IFwiYWVyb3NvbF9vcHRpY2FsX2RlcHRoXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJjYXJib25fbW9ub3hpZGVcIl0gPSA3OV0gPSBcImNhcmJvbl9tb25veGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wibml0cm9nZW5fZGlveGlkZVwiXSA9IDgwXSA9IFwibml0cm9nZW5fZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiYW1tb25pYVwiXSA9IDgxXSA9IFwiYW1tb25pYVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wib3pvbmVcIl0gPSA4Ml0gPSBcIm96b25lXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJzdWxwaHVyX2Rpb3hpZGVcIl0gPSA4M10gPSBcInN1bHBodXJfZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiYWxkZXJfcG9sbGVuXCJdID0gODRdID0gXCJhbGRlcl9wb2xsZW5cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImJpcmNoX3BvbGxlblwiXSA9IDg1XSA9IFwiYmlyY2hfcG9sbGVuXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJncmFzc19wb2xsZW5cIl0gPSA4Nl0gPSBcImdyYXNzX3BvbGxlblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wibXVnd29ydF9wb2xsZW5cIl0gPSA4N10gPSBcIm11Z3dvcnRfcG9sbGVuXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJvbGl2ZV9wb2xsZW5cIl0gPSA4OF0gPSBcIm9saXZlX3BvbGxlblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wicmFnd2VlZF9wb2xsZW5cIl0gPSA4OV0gPSBcInJhZ3dlZWRfcG9sbGVuXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJldXJvcGVhbl9hcWlcIl0gPSA5MF0gPSBcImV1cm9wZWFuX2FxaVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZXVyb3BlYW5fYXFpX3BtMnA1XCJdID0gOTFdID0gXCJldXJvcGVhbl9hcWlfcG0ycDVcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImV1cm9wZWFuX2FxaV9wbTEwXCJdID0gOTJdID0gXCJldXJvcGVhbl9hcWlfcG0xMFwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZXVyb3BlYW5fYXFpX25pdHJvZ2VuX2Rpb3hpZGVcIl0gPSA5M10gPSBcImV1cm9wZWFuX2FxaV9uaXRyb2dlbl9kaW94aWRlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJldXJvcGVhbl9hcWlfb3pvbmVcIl0gPSA5NF0gPSBcImV1cm9wZWFuX2FxaV9vem9uZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZXVyb3BlYW5fYXFpX3N1bHBodXJfZGlveGlkZVwiXSA9IDk1XSA9IFwiZXVyb3BlYW5fYXFpX3N1bHBodXJfZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXNfYXFpXCJdID0gOTZdID0gXCJ1c19hcWlcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInVzX2FxaV9wbTJwNVwiXSA9IDk3XSA9IFwidXNfYXFpX3BtMnA1XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ1c19hcWlfcG0xMFwiXSA9IDk4XSA9IFwidXNfYXFpX3BtMTBcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInVzX2FxaV9uaXRyb2dlbl9kaW94aWRlXCJdID0gOTldID0gXCJ1c19hcWlfbml0cm9nZW5fZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXNfYXFpX296b25lXCJdID0gMTAwXSA9IFwidXNfYXFpX296b25lXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJ1c19hcWlfc3VscGh1cl9kaW94aWRlXCJdID0gMTAxXSA9IFwidXNfYXFpX3N1bHBodXJfZGlveGlkZVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1widXNfYXFpX2NhcmJvbl9tb25veGlkZVwiXSA9IDEwMl0gPSBcInVzX2FxaV9jYXJib25fbW9ub3hpZGVcIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcInN1bnNoaW5lX2R1cmF0aW9uXCJdID0gMTAzXSA9IFwic3Vuc2hpbmVfZHVyYXRpb25cIjtcbiAgICBWYXJpYWJsZVtWYXJpYWJsZVtcImNvbnZlY3RpdmVfaW5oaWJpdGlvblwiXSA9IDEwNF0gPSBcImNvbnZlY3RpdmVfaW5oaWJpdGlvblwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wic2hvcnR3YXZlX3JhZGlhdGlvbl9jbGVhcl9za3lcIl0gPSAxMDVdID0gXCJzaG9ydHdhdmVfcmFkaWF0aW9uX2NsZWFyX3NreVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wiZ2xvYmFsX3RpbHRlZF9pcnJhZGlhbmNlXCJdID0gMTA2XSA9IFwiZ2xvYmFsX3RpbHRlZF9pcnJhZGlhbmNlXCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJnbG9iYWxfdGlsdGVkX2lycmFkaWFuY2VfaW5zdGFudFwiXSA9IDEwN10gPSBcImdsb2JhbF90aWx0ZWRfaXJyYWRpYW5jZV9pbnN0YW50XCI7XG4gICAgVmFyaWFibGVbVmFyaWFibGVbXCJvY2Vhbl9jdXJyZW50X3ZlbG9jaXR5XCJdID0gMTA4XSA9IFwib2NlYW5fY3VycmVudF92ZWxvY2l0eVwiO1xuICAgIFZhcmlhYmxlW1ZhcmlhYmxlW1wib2NlYW5fY3VycmVudF9kaXJlY3Rpb25cIl0gPSAxMDldID0gXCJvY2Vhbl9jdXJyZW50X2RpcmVjdGlvblwiO1xufSkoVmFyaWFibGUgfHwgKGV4cG9ydHMuVmFyaWFibGUgPSBWYXJpYWJsZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBGbGF0QnVmZmVycyBjb21waWxlciwgZG8gbm90IG1vZGlmeVxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlc1dpdGhUaW1lID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG5jb25zdCBmbGF0YnVmZmVycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZmxhdGJ1ZmZlcnNcIikpO1xuY29uc3QgdmFyaWFibGVfd2l0aF92YWx1ZXNfanNfMSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlLXdpdGgtdmFsdWVzLmpzXCIpO1xuY2xhc3MgVmFyaWFibGVzV2l0aFRpbWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJiID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYl9wb3MgPSAwO1xuICAgIH1cbiAgICBfX2luaXQoaSwgYmIpIHtcbiAgICAgICAgdGhpcy5iYl9wb3MgPSBpO1xuICAgICAgICB0aGlzLmJiID0gYmI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Um9vdEFzVmFyaWFibGVzV2l0aFRpbWUoYmIsIG9iaikge1xuICAgICAgICByZXR1cm4gKG9iaiB8fCBuZXcgVmFyaWFibGVzV2l0aFRpbWUoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1ZhcmlhYmxlc1dpdGhUaW1lKGJiLCBvYmopIHtcbiAgICAgICAgYmIuc2V0UG9zaXRpb24oYmIucG9zaXRpb24oKSArIGZsYXRidWZmZXJzLlNJWkVfUFJFRklYX0xFTkdUSCk7XG4gICAgICAgIHJldHVybiAob2JqIHx8IG5ldyBWYXJpYWJsZXNXaXRoVGltZSgpKS5fX2luaXQoYmIucmVhZEludDMyKGJiLnBvc2l0aW9uKCkpICsgYmIucG9zaXRpb24oKSwgYmIpO1xuICAgIH1cbiAgICB0aW1lKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IEJpZ0ludCgnMCcpO1xuICAgIH1cbiAgICB0aW1lRW5kKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA2KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEludDY0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IEJpZ0ludCgnMCcpO1xuICAgIH1cbiAgICBpbnRlcnZhbCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cbiAgICB2YXJpYWJsZXMoaW5kZXgsIG9iaikge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyAob2JqIHx8IG5ldyB2YXJpYWJsZV93aXRoX3ZhbHVlc19qc18xLlZhcmlhYmxlV2l0aFZhbHVlcygpKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmIuX192ZWN0b3IodGhpcy5iYl9wb3MgKyBvZmZzZXQpICsgaW5kZXggKiA0KSwgdGhpcy5iYikgOiBudWxsO1xuICAgIH1cbiAgICB2YXJpYWJsZXNMZW5ndGgoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIuX192ZWN0b3JfbGVuKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDA7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZXNXaXRoVGltZSA9IFZhcmlhYmxlc1dpdGhUaW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSB0aGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIsIGRvIG5vdCBtb2RpZnlcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWF0aGVyQXBpUmVzcG9uc2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb24gKi9cbmNvbnN0IGZsYXRidWZmZXJzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJmbGF0YnVmZmVyc1wiKSk7XG5jb25zdCBtb2RlbF9qc18xID0gcmVxdWlyZShcIi4vbW9kZWwuanNcIik7XG5jb25zdCB2YXJpYWJsZXNfd2l0aF90aW1lX2pzXzEgPSByZXF1aXJlKFwiLi92YXJpYWJsZXMtd2l0aC10aW1lLmpzXCIpO1xuY2xhc3MgV2VhdGhlckFwaVJlc3BvbnNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5iYiA9IG51bGw7XG4gICAgICAgIHRoaXMuYmJfcG9zID0gMDtcbiAgICB9XG4gICAgX19pbml0KGksIGJiKSB7XG4gICAgICAgIHRoaXMuYmJfcG9zID0gaTtcbiAgICAgICAgdGhpcy5iYiA9IGJiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhdGljIGdldFJvb3RBc1dlYXRoZXJBcGlSZXNwb25zZShiYiwgb2JqKSB7XG4gICAgICAgIHJldHVybiAob2JqIHx8IG5ldyBXZWF0aGVyQXBpUmVzcG9uc2UoKSkuX19pbml0KGJiLnJlYWRJbnQzMihiYi5wb3NpdGlvbigpKSArIGJiLnBvc2l0aW9uKCksIGJiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFNpemVQcmVmaXhlZFJvb3RBc1dlYXRoZXJBcGlSZXNwb25zZShiYiwgb2JqKSB7XG4gICAgICAgIGJiLnNldFBvc2l0aW9uKGJiLnBvc2l0aW9uKCkgKyBmbGF0YnVmZmVycy5TSVpFX1BSRUZJWF9MRU5HVEgpO1xuICAgICAgICByZXR1cm4gKG9iaiB8fCBuZXcgV2VhdGhlckFwaVJlc3BvbnNlKCkpLl9faW5pdChiYi5yZWFkSW50MzIoYmIucG9zaXRpb24oKSkgKyBiYi5wb3NpdGlvbigpLCBiYik7XG4gICAgfVxuICAgIGxhdGl0dWRlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCA0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMC4wO1xuICAgIH1cbiAgICBsb25naXR1ZGUoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDYpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gdGhpcy5iYi5yZWFkRmxvYXQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwLjA7XG4gICAgfVxuICAgIGVsZXZhdGlvbigpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgOCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRGbG9hdDMyKHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IDAuMDtcbiAgICB9XG4gICAgZ2VuZXJhdGlvblRpbWVNaWxsaXNlY29uZHMoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDEwKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZEZsb2F0MzIodGhpcy5iYl9wb3MgKyBvZmZzZXQpIDogMC4wO1xuICAgIH1cbiAgICBsb2NhdGlvbklkKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxMik7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQ2NCh0aGlzLmJiX3BvcyArIG9mZnNldCkgOiBCaWdJbnQoJzAnKTtcbiAgICB9XG4gICAgbW9kZWwoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIucmVhZFVpbnQ4KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSA6IG1vZGVsX2pzXzEuTW9kZWwudW5kZWZpbmVkO1xuICAgIH1cbiAgICB1dGNPZmZzZXRTZWNvbmRzKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAxNik7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLnJlYWRJbnQzMih0aGlzLmJiX3BvcyArIG9mZnNldCkgOiAwO1xuICAgIH1cbiAgICB0aW1lem9uZShvcHRpb25hbEVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDE4KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IHRoaXMuYmIuX19zdHJpbmcodGhpcy5iYl9wb3MgKyBvZmZzZXQsIG9wdGlvbmFsRW5jb2RpbmcpIDogbnVsbDtcbiAgICB9XG4gICAgdGltZXpvbmVBYmJyZXZpYXRpb24ob3B0aW9uYWxFbmNvZGluZykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmJiLl9fb2Zmc2V0KHRoaXMuYmJfcG9zLCAyMCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPyB0aGlzLmJiLl9fc3RyaW5nKHRoaXMuYmJfcG9zICsgb2Zmc2V0LCBvcHRpb25hbEVuY29kaW5nKSA6IG51bGw7XG4gICAgfVxuICAgIGN1cnJlbnQob2JqKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDIyKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IHZhcmlhYmxlc193aXRoX3RpbWVfanNfMS5WYXJpYWJsZXNXaXRoVGltZSgpKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYikgOiBudWxsO1xuICAgIH1cbiAgICBkYWlseShvYmopIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMjQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgdmFyaWFibGVzX3dpdGhfdGltZV9qc18xLlZhcmlhYmxlc1dpdGhUaW1lKCkpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiKSA6IG51bGw7XG4gICAgfVxuICAgIGhvdXJseShvYmopIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5iYi5fX29mZnNldCh0aGlzLmJiX3BvcywgMjYpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0ID8gKG9iaiB8fCBuZXcgdmFyaWFibGVzX3dpdGhfdGltZV9qc18xLlZhcmlhYmxlc1dpdGhUaW1lKCkpLl9faW5pdCh0aGlzLmJiLl9faW5kaXJlY3QodGhpcy5iYl9wb3MgKyBvZmZzZXQpLCB0aGlzLmJiKSA6IG51bGw7XG4gICAgfVxuICAgIG1pbnV0ZWx5MTUob2JqKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDI4KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IHZhcmlhYmxlc193aXRoX3RpbWVfanNfMS5WYXJpYWJsZXNXaXRoVGltZSgpKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYikgOiBudWxsO1xuICAgIH1cbiAgICBzaXhIb3VybHkob2JqKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmIuX19vZmZzZXQodGhpcy5iYl9wb3MsIDMwKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCA/IChvYmogfHwgbmV3IHZhcmlhYmxlc193aXRoX3RpbWVfanNfMS5WYXJpYWJsZXNXaXRoVGltZSgpKS5fX2luaXQodGhpcy5iYi5fX2luZGlyZWN0KHRoaXMuYmJfcG9zICsgb2Zmc2V0KSwgdGhpcy5iYikgOiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuV2VhdGhlckFwaVJlc3BvbnNlID0gV2VhdGhlckFwaVJlc3BvbnNlO1xuIiwiaW1wb3J0IHsgQnl0ZUJ1ZmZlciB9IGZyb20gXCIuL2J5dGUtYnVmZmVyLmpzXCI7XG5pbXBvcnQgeyBTSVpFT0ZfU0hPUlQsIFNJWkVfUFJFRklYX0xFTkdUSCwgU0laRU9GX0lOVCwgRklMRV9JREVOVElGSUVSX0xFTkdUSCB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuZXhwb3J0IGNsYXNzIEJ1aWxkZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEZsYXRCdWZmZXJCdWlsZGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdF9pbml0aWFsX3NpemUpIHtcbiAgICAgICAgLyoqIE1pbmltdW0gYWxpZ25tZW50IGVuY291bnRlcmVkIHNvIGZhci4gKi9cbiAgICAgICAgdGhpcy5taW5hbGlnbiA9IDE7XG4gICAgICAgIC8qKiBUaGUgdnRhYmxlIGZvciB0aGUgY3VycmVudCB0YWJsZS4gKi9cbiAgICAgICAgdGhpcy52dGFibGUgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGFtb3VudCBvZiBmaWVsZHMgd2UncmUgYWN0dWFsbHkgdXNpbmcuICovXG4gICAgICAgIHRoaXMudnRhYmxlX2luX3VzZSA9IDA7XG4gICAgICAgIC8qKiBXaGV0aGVyIHdlIGFyZSBjdXJyZW50bHkgc2VyaWFsaXppbmcgYSB0YWJsZS4gKi9cbiAgICAgICAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xuICAgICAgICAvKiogU3RhcnRpbmcgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IHN0cnVjdC90YWJsZS4gKi9cbiAgICAgICAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xuICAgICAgICAvKiogTGlzdCBvZiBvZmZzZXRzIG9mIGFsbCB2dGFibGVzLiAqL1xuICAgICAgICB0aGlzLnZ0YWJsZXMgPSBbXTtcbiAgICAgICAgLyoqIEZvciB0aGUgY3VycmVudCB2ZWN0b3IgYmVpbmcgYnVpbHQuICovXG4gICAgICAgIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IDA7XG4gICAgICAgIC8qKiBGYWxzZSBvbWl0cyBkZWZhdWx0IHZhbHVlcyBmcm9tIHRoZSBzZXJpYWxpemVkIGRhdGEgKi9cbiAgICAgICAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cmluZ19tYXBzID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0X2VuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgbGV0IGluaXRpYWxfc2l6ZTtcbiAgICAgICAgaWYgKCFvcHRfaW5pdGlhbF9zaXplKSB7XG4gICAgICAgICAgICBpbml0aWFsX3NpemUgPSAxMDI0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhbF9zaXplID0gb3B0X2luaXRpYWxfc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0J5dGVCdWZmZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJiID0gQnl0ZUJ1ZmZlci5hbGxvY2F0ZShpbml0aWFsX3NpemUpO1xuICAgICAgICB0aGlzLnNwYWNlID0gaW5pdGlhbF9zaXplO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5iYi5jbGVhcigpO1xuICAgICAgICB0aGlzLnNwYWNlID0gdGhpcy5iYi5jYXBhY2l0eSgpO1xuICAgICAgICB0aGlzLm1pbmFsaWduID0gMTtcbiAgICAgICAgdGhpcy52dGFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLnZ0YWJsZV9pbl91c2UgPSAwO1xuICAgICAgICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub2JqZWN0X3N0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy52dGFibGVzID0gW107XG4gICAgICAgIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IDA7XG4gICAgICAgIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdHJpbmdfbWFwcyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluIG9yZGVyIHRvIHNhdmUgc3BhY2UsIGZpZWxkcyB0aGF0IGFyZSBzZXQgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZVxuICAgICAqIGRvbid0IGdldCBzZXJpYWxpemVkIGludG8gdGhlIGJ1ZmZlci4gRm9yY2luZyBkZWZhdWx0cyBwcm92aWRlcyBhXG4gICAgICogd2F5IHRvIG1hbnVhbGx5IGRpc2FibGUgdGhpcyBvcHRpbWl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEZWZhdWx0cyB0cnVlIGFsd2F5cyBzZXJpYWxpemVzIGRlZmF1bHQgdmFsdWVzXG4gICAgICovXG4gICAgZm9yY2VEZWZhdWx0cyhmb3JjZURlZmF1bHRzKSB7XG4gICAgICAgIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmb3JjZURlZmF1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEJ5dGVCdWZmZXIgcmVwcmVzZW50aW5nIHRoZSBGbGF0QnVmZmVyLiBPbmx5IGNhbGwgdGhpcyBhZnRlciB5b3UndmVcbiAgICAgKiBjYWxsZWQgZmluaXNoKCkuIFRoZSBhY3R1YWwgZGF0YSBzdGFydHMgYXQgdGhlIEJ5dGVCdWZmZXIncyBjdXJyZW50IHBvc2l0aW9uLFxuICAgICAqIG5vdCBuZWNlc3NhcmlseSBhdCAwLlxuICAgICAqL1xuICAgIGRhdGFCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgRmxhdEJ1ZmZlci4gT25seSBjYWxsIHRoaXMgYWZ0ZXIgeW91J3ZlXG4gICAgICogY2FsbGVkIGZpbmlzaCgpLlxuICAgICAqL1xuICAgIGFzVWludDhBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksIHRoaXMuYmIucG9zaXRpb24oKSArIHRoaXMub2Zmc2V0KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRvIHdyaXRlIGFuIGVsZW1lbnQgb2YgYHNpemVgIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYCBoYXZlIGJlZW5cbiAgICAgKiB3cml0dGVuLCBlLmcuIGlmIHlvdSB3cml0ZSBhIHN0cmluZywgeW91IG5lZWQgdG8gYWxpZ24gc3VjaCB0aGUgaW50IGxlbmd0aFxuICAgICAqIGZpZWxkIGlzIGFsaWduZWQgdG8gNCBieXRlcywgYW5kIHRoZSBzdHJpbmcgZGF0YSBmb2xsb3dzIGl0IGRpcmVjdGx5LiBJZiBhbGxcbiAgICAgKiB5b3UgbmVlZCB0byBkbyBpcyBhbGlnbm1lbnQsIGBhZGRpdGlvbmFsX2J5dGVzYCB3aWxsIGJlIDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2l6ZSBUaGlzIGlzIHRoZSBvZiB0aGUgbmV3IGVsZW1lbnQgdG8gd3JpdGVcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbF9ieXRlcyBUaGUgcGFkZGluZyBzaXplXG4gICAgICovXG4gICAgcHJlcChzaXplLCBhZGRpdGlvbmFsX2J5dGVzKSB7XG4gICAgICAgIC8vIFRyYWNrIHRoZSBiaWdnZXN0IHRoaW5nIHdlJ3ZlIGV2ZXIgYWxpZ25lZCB0by5cbiAgICAgICAgaWYgKHNpemUgPiB0aGlzLm1pbmFsaWduKSB7XG4gICAgICAgICAgICB0aGlzLm1pbmFsaWduID0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBhbW91bnQgb2YgYWxpZ25tZW50IG5lZWRlZCBzdWNoIHRoYXQgYHNpemVgIGlzIHByb3Blcmx5XG4gICAgICAgIC8vIGFsaWduZWQgYWZ0ZXIgYGFkZGl0aW9uYWxfYnl0ZXNgXG4gICAgICAgIGNvbnN0IGFsaWduX3NpemUgPSAoKH4odGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSArIGFkZGl0aW9uYWxfYnl0ZXMpKSArIDEpICYgKHNpemUgLSAxKTtcbiAgICAgICAgLy8gUmVhbGxvY2F0ZSB0aGUgYnVmZmVyIGlmIG5lZWRlZC5cbiAgICAgICAgd2hpbGUgKHRoaXMuc3BhY2UgPCBhbGlnbl9zaXplICsgc2l6ZSArIGFkZGl0aW9uYWxfYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZF9idWZfc2l6ZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuYmIgPSBCdWlsZGVyLmdyb3dCeXRlQnVmZmVyKHRoaXMuYmIpO1xuICAgICAgICAgICAgdGhpcy5zcGFjZSArPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSBvbGRfYnVmX3NpemU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYWQoYWxpZ25fc2l6ZSk7XG4gICAgfVxuICAgIHBhZChieXRlX3NpemUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlX3NpemU7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5iYi53cml0ZUludDgoLS10aGlzLnNwYWNlLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUludDgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYi53cml0ZUludDgodGhpcy5zcGFjZSAtPSAxLCB2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlSW50MTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UgLT0gMiwgdmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZUludDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbnQ2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJiLndyaXRlSW50NjQodGhpcy5zcGFjZSAtPSA4LCB2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlRmxvYXQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLmJiLndyaXRlRmxvYXQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVGbG9hdDY0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmIud3JpdGVGbG9hdDY0KHRoaXMuc3BhY2UgLT0gOCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYGludDhgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYGludDhgIHRvIGFkZCB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGFkZEludDgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVwKDEsIDApO1xuICAgICAgICB0aGlzLndyaXRlSW50OCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBgaW50MTZgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYGludDE2YCB0byBhZGQgdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBhZGRJbnQxNih2YWx1ZSkge1xuICAgICAgICB0aGlzLnByZXAoMiwgMCk7XG4gICAgICAgIHRoaXMud3JpdGVJbnQxNih2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBgaW50MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYGludDMyYCB0byBhZGQgdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBhZGRJbnQzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLnByZXAoNCwgMCk7XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMih2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBgaW50NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYGludDY0YCB0byBhZGQgdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBhZGRJbnQ2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnByZXAoOCwgMCk7XG4gICAgICAgIHRoaXMud3JpdGVJbnQ2NCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGBmbG9hdDMyYCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGBmbG9hdDMyYCB0byBhZGQgdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBhZGRGbG9hdDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJlcCg0LCAwKTtcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0MzIodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBgZmxvYXQ2NGAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgZmxvYXQ2NGAgdG8gYWRkIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgYWRkRmxvYXQ2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnByZXAoOCwgMCk7XG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDY0KHZhbHVlKTtcbiAgICB9XG4gICAgYWRkRmllbGRJbnQ4KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEludDgodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEZpZWxkSW50MTYodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW50MTYodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEZpZWxkSW50MzIodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW50MzIodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEZpZWxkSW50NjQodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEludDY0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRGaWVsZEZsb2F0MzIodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmxvYXQzMih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRmllbGRGbG9hdDY0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEZsb2F0NjQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEZpZWxkT2Zmc2V0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE9mZnNldCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RydWN0cyBhcmUgc3RvcmVkIGlubGluZSwgc28gbm90aGluZyBhZGRpdGlvbmFsIGlzIGJlaW5nIGFkZGVkLiBgZGAgaXMgYWx3YXlzIDAuXG4gICAgICovXG4gICAgYWRkRmllbGRTdHJ1Y3Qodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RydWN0dXJlcyBhcmUgYWx3YXlzIHN0b3JlZCBpbmxpbmUsIHRoZXkgbmVlZCB0byBiZSBjcmVhdGVkIHJpZ2h0XG4gICAgICogd2hlcmUgdGhleSdyZSB1c2VkLiAgWW91J2xsIGdldCB0aGlzIGFzc2VydGlvbiBmYWlsdXJlIGlmIHlvdVxuICAgICAqIGNyZWF0ZWQgaXQgZWxzZXdoZXJlLlxuICAgICAqL1xuICAgIG5lc3RlZChvYmopIHtcbiAgICAgICAgaWYgKG9iaiAhPSB0aGlzLm9mZnNldCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGbGF0QnVmZmVyczogc3RydWN0IG11c3QgYmUgc2VyaWFsaXplZCBpbmxpbmUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdWxkIG5vdCBiZSBjcmVhdGluZyBhbnkgb3RoZXIgb2JqZWN0LCBzdHJpbmcgb3IgdmVjdG9yXG4gICAgICogd2hpbGUgYW4gb2JqZWN0IGlzIGJlaW5nIGNvbnN0cnVjdGVkXG4gICAgICovXG4gICAgbm90TmVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pc05lc3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgdnRhYmxlIGF0IGB2b2Zmc2V0YCB0byB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIHNsb3Qodm9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy52dGFibGUgIT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnZ0YWJsZVt2b2Zmc2V0XSA9IHRoaXMub2Zmc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIE9mZnNldCByZWxhdGl2ZSB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG91YmxlcyB0aGUgc2l6ZSBvZiB0aGUgYmFja2luZyBCeXRlQnVmZmVyIGFuZCBjb3BpZXMgdGhlIG9sZCBkYXRhIHRvd2FyZHNcbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBuZXcgYnVmZmVyIChzaW5jZSB3ZSBidWlsZCB0aGUgYnVmZmVyIGJhY2t3YXJkcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmIgVGhlIGN1cnJlbnQgYnVmZmVyIHdpdGggdGhlIGV4aXN0aW5nIGRhdGFcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBieXRlIGJ1ZmZlciB3aXRoIHRoZSBvbGQgZGF0YSBjb3BpZWRcbiAgICAgKiB0byBpdC4gVGhlIGRhdGEgaXMgbG9jYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXG4gICAgICpcbiAgICAgKiB1aW50OEFycmF5LnNldCgpIGZvcm1hbGx5IHRha2VzIHtBcnJheTxudW1iZXI+fEFycmF5QnVmZmVyVmlld30sIHNvIHRvIHBhc3NcbiAgICAgKiBpdCBhIHVpbnQ4QXJyYXkgd2UgbmVlZCB0byBzdXBwcmVzcyB0aGUgdHlwZSBjaGVjazpcbiAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAgICovXG4gICAgc3RhdGljIGdyb3dCeXRlQnVmZmVyKGJiKSB7XG4gICAgICAgIGNvbnN0IG9sZF9idWZfc2l6ZSA9IGJiLmNhcGFjaXR5KCk7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBncm93IGJleW9uZCB3aGF0IGZpdHMgaW4gYW4gaW50LlxuICAgICAgICBpZiAob2xkX2J1Zl9zaXplICYgMHhDMDAwMDAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdfYnVmX3NpemUgPSBvbGRfYnVmX3NpemUgPDwgMTtcbiAgICAgICAgY29uc3QgbmJiID0gQnl0ZUJ1ZmZlci5hbGxvY2F0ZShuZXdfYnVmX3NpemUpO1xuICAgICAgICBuYmIuc2V0UG9zaXRpb24obmV3X2J1Zl9zaXplIC0gb2xkX2J1Zl9zaXplKTtcbiAgICAgICAgbmJiLmJ5dGVzKCkuc2V0KGJiLmJ5dGVzKCksIG5ld19idWZfc2l6ZSAtIG9sZF9idWZfc2l6ZSk7XG4gICAgICAgIHJldHVybiBuYmI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgb24gb2Zmc2V0LCByZWxhdGl2ZSB0byB3aGVyZSBpdCB3aWxsIGJlIHdyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5wcmVwKFNJWkVPRl9JTlQsIDApOyAvLyBFbnN1cmUgYWxpZ25tZW50IGlzIGFscmVhZHkgZG9uZS5cbiAgICAgICAgdGhpcy53cml0ZUludDMyKHRoaXMub2Zmc2V0KCkgLSBvZmZzZXQgKyBTSVpFT0ZfSU5UKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgZW5jb2RpbmcgYSBuZXcgb2JqZWN0IGluIHRoZSBidWZmZXIuICBVc2VycyB3aWxsIG5vdCB1c3VhbGx5IG5lZWQgdG9cbiAgICAgKiBjYWxsIHRoaXMgZGlyZWN0bHkuIFRoZSBGbGF0QnVmZmVycyBjb21waWxlciB3aWxsIGdlbmVyYXRlIGhlbHBlciBtZXRob2RzXG4gICAgICogdGhhdCBjYWxsIHRoaXMgbWV0aG9kIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhcnRPYmplY3QobnVtZmllbGRzKSB7XG4gICAgICAgIHRoaXMubm90TmVzdGVkKCk7XG4gICAgICAgIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZ0YWJsZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudnRhYmxlX2luX3VzZSA9IG51bWZpZWxkcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1maWVsZHM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52dGFibGVbaV0gPSAwOyAvLyBUaGlzIHdpbGwgcHVzaCBhZGRpdGlvbmFsIGVsZW1lbnRzIGFzIG5lZWRlZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9iamVjdF9zdGFydCA9IHRoaXMub2Zmc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBvZmYgd3JpdGluZyB0aGUgb2JqZWN0IHRoYXQgaXMgdW5kZXIgY29uc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG9mZnNldCB0byB0aGUgb2JqZWN0IGluc2lkZSBgZGF0YUJ1ZmZlcmBcbiAgICAgKi9cbiAgICBlbmRPYmplY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsIHx8ICF0aGlzLmlzTmVzdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBlbmRPYmplY3QgY2FsbGVkIHdpdGhvdXQgc3RhcnRPYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEludDMyKDApO1xuICAgICAgICBjb25zdCB2dGFibGVsb2MgPSB0aGlzLm9mZnNldCgpO1xuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIHplcm9lcy5cbiAgICAgICAgbGV0IGkgPSB0aGlzLnZ0YWJsZV9pbl91c2UgLSAxO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgZm9yICg7IGkgPj0gMCAmJiB0aGlzLnZ0YWJsZVtpXSA9PSAwOyBpLS0pIHsgfVxuICAgICAgICBjb25zdCB0cmltbWVkX3NpemUgPSBpICsgMTtcbiAgICAgICAgLy8gV3JpdGUgb3V0IHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZS5cbiAgICAgICAgICAgIHRoaXMuYWRkSW50MTYodGhpcy52dGFibGVbaV0gIT0gMCA/IHZ0YWJsZWxvYyAtIHRoaXMudnRhYmxlW2ldIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhbmRhcmRfZmllbGRzID0gMjsgLy8gVGhlIGZpZWxkcyBiZWxvdzpcbiAgICAgICAgdGhpcy5hZGRJbnQxNih2dGFibGVsb2MgLSB0aGlzLm9iamVjdF9zdGFydCk7XG4gICAgICAgIGNvbnN0IGxlbiA9ICh0cmltbWVkX3NpemUgKyBzdGFuZGFyZF9maWVsZHMpICogU0laRU9GX1NIT1JUO1xuICAgICAgICB0aGlzLmFkZEludDE2KGxlbik7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYW4gZXhpc3RpbmcgdnRhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgIGxldCBleGlzdGluZ192dGFibGUgPSAwO1xuICAgICAgICBjb25zdCB2dDEgPSB0aGlzLnNwYWNlO1xuICAgICAgICBvdXRlcl9sb29wOiBmb3IgKGkgPSAwOyBpIDwgdGhpcy52dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2dDIgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgICAgICAgICBpZiAobGVuID09IHRoaXMuYmIucmVhZEludDE2KHZ0MikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gU0laRU9GX1NIT1JUOyBqIDwgbGVuOyBqICs9IFNJWkVPRl9TSE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5iYi5yZWFkSW50MTYodnQxICsgaikgIT0gdGhpcy5iYi5yZWFkSW50MTYodnQyICsgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyX2xvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdfdnRhYmxlID0gdGhpcy52dGFibGVzW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleGlzdGluZ192dGFibGUpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2g6XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgdnRhYmxlLlxuICAgICAgICAgICAgdGhpcy5zcGFjZSA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHZ0YWJsZWxvYztcbiAgICAgICAgICAgIC8vIFBvaW50IHRhYmxlIHRvIGV4aXN0aW5nIHZ0YWJsZS5cbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLCBleGlzdGluZ192dGFibGUgLSB2dGFibGVsb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbWF0Y2g6XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IHZ0YWJsZSB0byB0aGUgbGlzdCBvZiB2dGFibGVzLlxuICAgICAgICAgICAgdGhpcy52dGFibGVzLnB1c2godGhpcy5vZmZzZXQoKSk7XG4gICAgICAgICAgICAvLyBQb2ludCB0YWJsZSB0byBjdXJyZW50IHZ0YWJsZS5cbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2MsIHRoaXMub2Zmc2V0KCkgLSB2dGFibGVsb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZ0YWJsZWxvYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluYWxpemUgYSBidWZmZXIsIHBvaXRpbmcgdG8gdGhlIGdpdmVuIGByb290X3RhYmxlYC5cbiAgICAgKi9cbiAgICBmaW5pc2gocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllciwgb3B0X3NpemVfcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IHNpemVfcHJlZml4ID0gb3B0X3NpemVfcHJlZml4ID8gU0laRV9QUkVGSVhfTEVOR1RIIDogMDtcbiAgICAgICAgaWYgKG9wdF9maWxlX2lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVfaWRlbnRpZmllciA9IG9wdF9maWxlX2lkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgU0laRU9GX0lOVCArXG4gICAgICAgICAgICAgICAgRklMRV9JREVOVElGSUVSX0xFTkdUSCArIHNpemVfcHJlZml4KTtcbiAgICAgICAgICAgIGlmIChmaWxlX2lkZW50aWZpZXIubGVuZ3RoICE9IEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGbGF0QnVmZmVyczogZmlsZSBpZGVudGlmaWVyIG11c3QgYmUgbGVuZ3RoICcgK1xuICAgICAgICAgICAgICAgICAgICBGSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBGSUxFX0lERU5USUZJRVJfTEVOR1RIIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW50OChmaWxlX2lkZW50aWZpZXIuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVwKHRoaXMubWluYWxpZ24sIFNJWkVPRl9JTlQgKyBzaXplX3ByZWZpeCk7XG4gICAgICAgIHRoaXMuYWRkT2Zmc2V0KHJvb3RfdGFibGUpO1xuICAgICAgICBpZiAoc2l6ZV9wcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluYWxpemUgYSBzaXplIHByZWZpeGVkIGJ1ZmZlciwgcG9pbnRpbmcgdG8gdGhlIGdpdmVuIGByb290X3RhYmxlYC5cbiAgICAgKi9cbiAgICBmaW5pc2hTaXplUHJlZml4ZWQocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLmZpbmlzaChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBjaGVja3MgYSByZXF1aXJlZCBmaWVsZCBoYXMgYmVlbiBzZXQgaW4gYSBnaXZlbiB0YWJsZSB0aGF0IGhhc1xuICAgICAqIGp1c3QgYmVlbiBjb25zdHJ1Y3RlZC5cbiAgICAgKi9cbiAgICByZXF1aXJlZEZpZWxkKHRhYmxlLCBmaWVsZCkge1xuICAgICAgICBjb25zdCB0YWJsZV9zdGFydCA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRhYmxlO1xuICAgICAgICBjb25zdCB2dGFibGVfc3RhcnQgPSB0YWJsZV9zdGFydCAtIHRoaXMuYmIucmVhZEludDMyKHRhYmxlX3N0YXJ0KTtcbiAgICAgICAgY29uc3Qgb2sgPSBmaWVsZCA8IHRoaXMuYmIucmVhZEludDE2KHZ0YWJsZV9zdGFydCkgJiZcbiAgICAgICAgICAgIHRoaXMuYmIucmVhZEludDE2KHZ0YWJsZV9zdGFydCArIGZpZWxkKSAhPSAwO1xuICAgICAgICAvLyBJZiB0aGlzIGZhaWxzLCB0aGUgY2FsbGVyIHdpbGwgc2hvdyB3aGF0IGZpZWxkIG5lZWRzIHRvIGJlIHNldC5cbiAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmxhdEJ1ZmZlcnM6IGZpZWxkICcgKyBmaWVsZCArICcgbXVzdCBiZSBzZXQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIG5ldyBhcnJheS92ZWN0b3Igb2Ygb2JqZWN0cy4gIFVzZXJzIHVzdWFsbHkgd2lsbCBub3QgY2FsbFxuICAgICAqIHRoaXMgZGlyZWN0bHkuIFRoZSBGbGF0QnVmZmVycyBjb21waWxlciB3aWxsIGNyZWF0ZSBhIHN0YXJ0L2VuZFxuICAgICAqIG1ldGhvZCBmb3IgdmVjdG9yIHR5cGVzIGluIGdlbmVyYXRlZCBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1fc2l6ZSBUaGUgc2l6ZSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5XG4gICAgICogQHBhcmFtIG51bV9lbGVtcyBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICAgICAqIEBwYXJhbSBhbGlnbm1lbnQgVGhlIGFsaWdubWVudCBvZiB0aGUgYXJyYXlcbiAgICAgKi9cbiAgICBzdGFydFZlY3RvcihlbGVtX3NpemUsIG51bV9lbGVtcywgYWxpZ25tZW50KSB7XG4gICAgICAgIHRoaXMubm90TmVzdGVkKCk7XG4gICAgICAgIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IG51bV9lbGVtcztcbiAgICAgICAgdGhpcy5wcmVwKFNJWkVPRl9JTlQsIGVsZW1fc2l6ZSAqIG51bV9lbGVtcyk7XG4gICAgICAgIHRoaXMucHJlcChhbGlnbm1lbnQsIGVsZW1fc2l6ZSAqIG51bV9lbGVtcyk7IC8vIEp1c3QgaW4gY2FzZSBhbGlnbm1lbnQgPiBpbnQuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBvZmYgdGhlIGNyZWF0aW9uIG9mIGFuIGFycmF5IGFuZCBhbGwgaXRzIGVsZW1lbnRzLiBUaGUgYXJyYXkgbXVzdCBiZVxuICAgICAqIGNyZWF0ZWQgd2l0aCBgc3RhcnRWZWN0b3JgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG9mZnNldCBhdCB3aGljaCB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheVxuICAgICAqIHN0YXJ0cy5cbiAgICAgKi9cbiAgICBlbmRWZWN0b3IoKSB7XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMih0aGlzLnZlY3Rvcl9udW1fZWxlbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIHRoZSBzdHJpbmcgYHNgIGluIHRoZSBidWZmZXIgdXNpbmcgVVRGLTguIElmIHRoZSBzdHJpbmcgcGFzc2VkIGhhc1xuICAgICAqIGFscmVhZHkgYmVlbiBzZWVuLCB3ZSByZXR1cm4gdGhlIG9mZnNldCBvZiB0aGUgYWxyZWFkeSB3cml0dGVuIHN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHMgVGhlIHN0cmluZyB0byBlbmNvZGVcbiAgICAgKiBAcmV0dXJuIFRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgZW5jb2RlZCBzdHJpbmcgc3RhcnRzXG4gICAgICovXG4gICAgY3JlYXRlU2hhcmVkU3RyaW5nKHMpIHtcbiAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc3RyaW5nX21hcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nX21hcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RyaW5nX21hcHMuaGFzKHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdfbWFwcy5nZXQocyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jcmVhdGVTdHJpbmcocyk7XG4gICAgICAgIHRoaXMuc3RyaW5nX21hcHMuc2V0KHMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgc3RyaW5nIGBzYCBpbiB0aGUgYnVmZmVyIHVzaW5nIFVURi04LiBJZiBhIFVpbnQ4QXJyYXkgaXMgcGFzc2VkXG4gICAgICogaW5zdGVhZCBvZiBhIHN0cmluZywgaXQgaXMgYXNzdW1lZCB0byBjb250YWluIHZhbGlkIFVURi04IGVuY29kZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzIFRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gICAgICogQHJldHVybiBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xuICAgICAqL1xuICAgIGNyZWF0ZVN0cmluZyhzKSB7XG4gICAgICAgIGlmIChzID09PSBudWxsIHx8IHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHV0Zjg7XG4gICAgICAgIGlmIChzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgdXRmOCA9IHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGY4ID0gdGhpcy50ZXh0X2VuY29kZXIuZW5jb2RlKHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkSW50OCgwKTtcbiAgICAgICAgdGhpcy5zdGFydFZlY3RvcigxLCB1dGY4Lmxlbmd0aCwgMSk7XG4gICAgICAgIHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSAtPSB1dGY4Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMuYmIuYnl0ZXMoKS5zZXQodXRmOCwgdGhpcy5zcGFjZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFZlY3RvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBieXRlIHZlY3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2IFRoZSBieXRlcyB0byBhZGRcbiAgICAgKiBAcmV0dXJucyBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGJ5dGUgdmVjdG9yIHN0YXJ0c1xuICAgICAqL1xuICAgIGNyZWF0ZUJ5dGVWZWN0b3Iodikge1xuICAgICAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRWZWN0b3IoMSwgdi5sZW5ndGgsIDEpO1xuICAgICAgICB0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UgLT0gdi5sZW5ndGgpO1xuICAgICAgICB0aGlzLmJiLmJ5dGVzKCkuc2V0KHYsIHRoaXMuc3BhY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRWZWN0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcGFjayBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIG9mZnNldCBvZiBvYmpcbiAgICAgKi9cbiAgICBjcmVhdGVPYmplY3RPZmZzZXQob2JqKSB7XG4gICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RyaW5nKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnBhY2sodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gdG8gcGFjayBhIGxpc3Qgb2Ygb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBsaXN0IG9mIG9mZnNldHMgb2YgZWFjaCBub24gbnVsbCBvYmplY3RcbiAgICAgKi9cbiAgICBjcmVhdGVPYmplY3RPZmZzZXRMaXN0KGxpc3QpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh0aGlzLmNyZWF0ZU9iamVjdE9mZnNldCh2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZsYXRCdWZmZXJzOiBBcmd1bWVudCBmb3IgY3JlYXRlT2JqZWN0T2Zmc2V0TGlzdCBjYW5ub3QgY29udGFpbiBudWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGNyZWF0ZVN0cnVjdE9mZnNldExpc3QobGlzdCwgc3RhcnRGdW5jKSB7XG4gICAgICAgIHN0YXJ0RnVuYyh0aGlzLCBsaXN0Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY3JlYXRlT2JqZWN0T2Zmc2V0TGlzdChsaXN0LnNsaWNlKCkucmV2ZXJzZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kVmVjdG9yKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRklMRV9JREVOVElGSUVSX0xFTkdUSCwgU0laRU9GX0lOVCB9IGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgaW50MzIsIGlzTGl0dGxlRW5kaWFuLCBmbG9hdDMyLCBmbG9hdDY0IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IEVuY29kaW5nIH0gZnJvbSBcIi4vZW5jb2RpbmcuanNcIjtcbmV4cG9ydCBjbGFzcyBCeXRlQnVmZmVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQnl0ZUJ1ZmZlciB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYnl0ZXMgKGBVaW50OEFycmF5YClcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihieXRlc18pIHtcbiAgICAgICAgdGhpcy5ieXRlc18gPSBieXRlc187XG4gICAgICAgIHRoaXMucG9zaXRpb25fID0gMDtcbiAgICAgICAgdGhpcy50ZXh0X2RlY29kZXJfID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgYWxsb2NhdGUgYSBuZXcgQnl0ZUJ1ZmZlciB3aXRoIGEgZ2l2ZW4gc2l6ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWxsb2NhdGUoYnl0ZV9zaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnl0ZUJ1ZmZlcihuZXcgVWludDhBcnJheShieXRlX3NpemUpKTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25fID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bmRlcmx5aW5nIGBVaW50OEFycmF5YC5cbiAgICAgKi9cbiAgICBieXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ1ZmZlcidzIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbl87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gICAgICovXG4gICAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl8gPSBwb3NpdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBidWZmZXIncyBjYXBhY2l0eS5cbiAgICAgKi9cbiAgICBjYXBhY2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfLmxlbmd0aDtcbiAgICB9XG4gICAgcmVhZEludDgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50OChvZmZzZXQpIDw8IDI0ID4+IDI0O1xuICAgIH1cbiAgICByZWFkVWludDgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdO1xuICAgIH1cbiAgICByZWFkSW50MTYob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRVaW50MTYob2Zmc2V0KSA8PCAxNiA+PiAxNjtcbiAgICB9XG4gICAgcmVhZFVpbnQxNihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfW29mZnNldF0gfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA8PCA4O1xuICAgIH1cbiAgICByZWFkSW50MzIob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDJdIDw8IDE2IHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgM10gPDwgMjQ7XG4gICAgfVxuICAgIHJlYWRVaW50MzIob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRJbnQzMihvZmZzZXQpID4+PiAwO1xuICAgIH1cbiAgICByZWFkSW50NjQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQuYXNJbnROKDY0LCBCaWdJbnQodGhpcy5yZWFkVWludDMyKG9mZnNldCkpICsgKEJpZ0ludCh0aGlzLnJlYWRVaW50MzIob2Zmc2V0ICsgNCkpIDw8IEJpZ0ludCgzMikpKTtcbiAgICB9XG4gICAgcmVhZFVpbnQ2NChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc1VpbnROKDY0LCBCaWdJbnQodGhpcy5yZWFkVWludDMyKG9mZnNldCkpICsgKEJpZ0ludCh0aGlzLnJlYWRVaW50MzIob2Zmc2V0ICsgNCkpIDw8IEJpZ0ludCgzMikpKTtcbiAgICB9XG4gICAgcmVhZEZsb2F0MzIob2Zmc2V0KSB7XG4gICAgICAgIGludDMyWzBdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGZsb2F0MzJbMF07XG4gICAgfVxuICAgIHJlYWRGbG9hdDY0KG9mZnNldCkge1xuICAgICAgICBpbnQzMltpc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gICAgICAgIGludDMyW2lzTGl0dGxlRW5kaWFuID8gMSA6IDBdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiBmbG9hdDY0WzBdO1xuICAgIH1cbiAgICB3cml0ZUludDgob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gICAgfVxuICAgIHdyaXRlVWludDgob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gICAgfVxuICAgIHdyaXRlSW50MTYob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbiAgICB9XG4gICAgd3JpdGVVaW50MTYob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcbiAgICB9XG4gICAgd3JpdGVJbnQzMihvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDE2O1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+IDI0O1xuICAgIH1cbiAgICB3cml0ZVVpbnQzMihvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDE2O1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAzXSA9IHZhbHVlID4+IDI0O1xuICAgIH1cbiAgICB3cml0ZUludDY0KG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgTnVtYmVyKEJpZ0ludC5hc0ludE4oMzIsIHZhbHVlKSkpO1xuICAgICAgICB0aGlzLndyaXRlSW50MzIob2Zmc2V0ICsgNCwgTnVtYmVyKEJpZ0ludC5hc0ludE4oMzIsIHZhbHVlID4+IEJpZ0ludCgzMikpKSk7XG4gICAgfVxuICAgIHdyaXRlVWludDY0KG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy53cml0ZVVpbnQzMihvZmZzZXQsIE51bWJlcihCaWdJbnQuYXNVaW50TigzMiwgdmFsdWUpKSk7XG4gICAgICAgIHRoaXMud3JpdGVVaW50MzIob2Zmc2V0ICsgNCwgTnVtYmVyKEJpZ0ludC5hc1VpbnROKDMyLCB2YWx1ZSA+PiBCaWdJbnQoMzIpKSkpO1xuICAgIH1cbiAgICB3cml0ZUZsb2F0MzIob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBmbG9hdDMyWzBdID0gdmFsdWU7XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIGludDMyWzBdKTtcbiAgICB9XG4gICAgd3JpdGVGbG9hdDY0KG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgZmxvYXQ2NFswXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBpbnQzMltpc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSk7XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBpbnQzMltpc0xpdHRsZUVuZGlhbiA/IDEgOiAwXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZmlsZSBpZGVudGlmaWVyLiAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBmb3IgRmxhdEJ1ZmZlcnMgd2hvc2VcbiAgICAgKiBzY2hlbWEgZG9lcyBub3QgaW5jbHVkZSBhIGZpbGVfaWRlbnRpZmllciAobGlrZWx5IHBvaW50cyBhdCBwYWRkaW5nIG9yIHRoZVxuICAgICAqIHN0YXJ0IG9mIGEgdGhlIHJvb3QgdnRhYmxlKS5cbiAgICAgKi9cbiAgICBnZXRCdWZmZXJJZGVudGlmaWVyKCkge1xuICAgICAgICBpZiAodGhpcy5ieXRlc18ubGVuZ3RoIDwgdGhpcy5wb3NpdGlvbl8gKyBTSVpFT0ZfSU5UICtcbiAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IEJ5dGVCdWZmZXIgaXMgdG9vIHNob3J0IHRvIGNvbnRhaW4gYW4gaWRlbnRpZmllci4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBGSUxFX0lERU5USUZJRVJfTEVOR1RIOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbl8gKyBTSVpFT0ZfSU5UICsgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2sgdXAgYSBmaWVsZCBpbiB0aGUgdnRhYmxlLCByZXR1cm4gYW4gb2Zmc2V0IGludG8gdGhlIG9iamVjdCwgb3IgMCBpZiB0aGVcbiAgICAgKiBmaWVsZCBpcyBub3QgcHJlc2VudC5cbiAgICAgKi9cbiAgICBfX29mZnNldChiYl9wb3MsIHZ0YWJsZV9vZmZzZXQpIHtcbiAgICAgICAgY29uc3QgdnRhYmxlID0gYmJfcG9zIC0gdGhpcy5yZWFkSW50MzIoYmJfcG9zKTtcbiAgICAgICAgcmV0dXJuIHZ0YWJsZV9vZmZzZXQgPCB0aGlzLnJlYWRJbnQxNih2dGFibGUpID8gdGhpcy5yZWFkSW50MTYodnRhYmxlICsgdnRhYmxlX29mZnNldCkgOiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGFueSBUYWJsZS1kZXJpdmVkIHR5cGUgdG8gcG9pbnQgdG8gdGhlIHVuaW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gICAgICovXG4gICAgX191bmlvbih0LCBvZmZzZXQpIHtcbiAgICAgICAgdC5iYl9wb3MgPSBvZmZzZXQgKyB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICAgICAgICB0LmJiID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEphdmFTY3JpcHQgc3RyaW5nIGZyb20gVVRGLTggZGF0YSBzdG9yZWQgaW5zaWRlIHRoZSBGbGF0QnVmZmVyLlxuICAgICAqIFRoaXMgYWxsb2NhdGVzIGEgbmV3IHN0cmluZyBhbmQgY29udmVydHMgdG8gd2lkZSBjaGFycyB1cG9uIGVhY2ggYWNjZXNzLlxuICAgICAqXG4gICAgICogVG8gYXZvaWQgdGhlIGNvbnZlcnNpb24gdG8gc3RyaW5nLCBwYXNzIEVuY29kaW5nLlVURjhfQllURVMgYXMgdGhlXG4gICAgICogXCJvcHRpb25hbEVuY29kaW5nXCIgYXJndW1lbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBhdm9pZGluZyBjb252ZXJzaW9uIHdoZW5cbiAgICAgKiB0aGUgZGF0YSB3aWxsIGp1c3QgYmUgcGFja2FnZWQgYmFjayB1cCBpbiBhbm90aGVyIEZsYXRCdWZmZXIgbGF0ZXIgb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHBhcmFtIG9wdF9lbmNvZGluZyBEZWZhdWx0cyB0byBVVEYxNl9TVFJJTkdcbiAgICAgKi9cbiAgICBfX3N0cmluZyhvZmZzZXQsIG9wdF9lbmNvZGluZykge1xuICAgICAgICBvZmZzZXQgKz0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IFNJWkVPRl9JTlQ7XG4gICAgICAgIGNvbnN0IHV0ZjhieXRlcyA9IHRoaXMuYnl0ZXNfLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgaWYgKG9wdF9lbmNvZGluZyA9PT0gRW5jb2RpbmcuVVRGOF9CWVRFUylcbiAgICAgICAgICAgIHJldHVybiB1dGY4Ynl0ZXM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHRfZGVjb2Rlcl8uZGVjb2RlKHV0ZjhieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB1bmlvbnMgdGhhdCBjYW4gY29udGFpbiBzdHJpbmcgYXMgaXRzIG1lbWJlciwgaWYgYSBUYWJsZS1kZXJpdmVkIHR5cGUgdGhlbiBpbml0aWFsaXplIGl0LFxuICAgICAqIGlmIGEgc3RyaW5nIHRoZW4gcmV0dXJuIGEgbmV3IG9uZVxuICAgICAqXG4gICAgICogV0FSTklORzogc3RyaW5ncyBhcmUgaW1tdXRhYmxlIGluIEpTIHNvIHdlIGNhbid0IGNoYW5nZSB0aGUgc3RyaW5nIHRoYXQgdGhlIHVzZXIgZ2F2ZSB1cywgdGhpc1xuICAgICAqIG1ha2VzIHRoZSBiZWhhdmlvdXIgb2YgX191bmlvbl93aXRoX3N0cmluZyBkaWZmZXJlbnQgY29tcGFyZWQgdG8gX191bmlvblxuICAgICAqL1xuICAgIF9fdW5pb25fd2l0aF9zdHJpbmcobywgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RyaW5nKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX191bmlvbihvLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcmVsYXRpdmUgb2Zmc2V0IHN0b3JlZCBhdCBcIm9mZnNldFwiXG4gICAgICovXG4gICAgX19pbmRpcmVjdChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhcnQgb2YgZGF0YSBvZiBhIHZlY3RvciB3aG9zZSBvZmZzZXQgaXMgc3RvcmVkIGF0IFwib2Zmc2V0XCIgaW4gdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgX192ZWN0b3Iob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyB0aGlzLnJlYWRJbnQzMihvZmZzZXQpICsgU0laRU9GX0lOVDsgLy8gZGF0YSBzdGFydHMgYWZ0ZXIgdGhlIGxlbmd0aFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB3aG9zZSBvZmZzZXQgaXMgc3RvcmVkIGF0IFwib2Zmc2V0XCIgaW4gdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgX192ZWN0b3JfbGVuKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSk7XG4gICAgfVxuICAgIF9faGFzX2lkZW50aWZpZXIoaWRlbnQpIHtcbiAgICAgICAgaWYgKGlkZW50Lmxlbmd0aCAhPSBGSUxFX0lERU5USUZJRVJfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggJyArXG4gICAgICAgICAgICAgICAgRklMRV9JREVOVElGSUVSX0xFTkdUSCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBGSUxFX0lERU5USUZJRVJfTEVOR1RIOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpZGVudC5jaGFyQ29kZUF0KGkpICE9IHRoaXMucmVhZEludDgodGhpcy5wb3NpdGlvbigpICsgU0laRU9GX0lOVCArIGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBsaXN0IGZvciBvYmogYXBpXG4gICAgICovXG4gICAgY3JlYXRlU2NhbGFyTGlzdChsaXN0QWNjZXNzb3IsIGxpc3RMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBsaXN0QWNjZXNzb3IoaSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2godmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBsaXN0IGZvciBvYmogYXBpXG4gICAgICogQHBhcmFtIGxpc3RBY2Nlc3NvciBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYW4gaW5kZXggYW5kIHJldHVybiBkYXRhIGF0IHRoYXQgaW5kZXhcbiAgICAgKiBAcGFyYW0gbGlzdExlbmd0aCBsaXN0TGVuZ3RoXG4gICAgICogQHBhcmFtIHJlcyByZXN1bHQgbGlzdFxuICAgICAqL1xuICAgIGNyZWF0ZU9iakxpc3QobGlzdEFjY2Vzc29yLCBsaXN0TGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gbGlzdEFjY2Vzc29yKGkpO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHZhbC51bnBhY2soKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG59XG4iLCJleHBvcnQgY29uc3QgU0laRU9GX1NIT1JUID0gMjtcbmV4cG9ydCBjb25zdCBTSVpFT0ZfSU5UID0gNDtcbmV4cG9ydCBjb25zdCBGSUxFX0lERU5USUZJRVJfTEVOR1RIID0gNDtcbmV4cG9ydCBjb25zdCBTSVpFX1BSRUZJWF9MRU5HVEggPSA0O1xuIiwiZXhwb3J0IHZhciBFbmNvZGluZztcbihmdW5jdGlvbiAoRW5jb2RpbmcpIHtcbiAgICBFbmNvZGluZ1tFbmNvZGluZ1tcIlVURjhfQllURVNcIl0gPSAxXSA9IFwiVVRGOF9CWVRFU1wiO1xuICAgIEVuY29kaW5nW0VuY29kaW5nW1wiVVRGMTZfU1RSSU5HXCJdID0gMl0gPSBcIlVURjE2X1NUUklOR1wiO1xufSkoRW5jb2RpbmcgfHwgKEVuY29kaW5nID0ge30pKTtcbiIsImV4cG9ydCB7IFNJWkVPRl9TSE9SVCB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmV4cG9ydCB7IFNJWkVPRl9JTlQgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5leHBvcnQgeyBGSUxFX0lERU5USUZJRVJfTEVOR1RIIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuZXhwb3J0IHsgU0laRV9QUkVGSVhfTEVOR1RIIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuZXhwb3J0IHsgaW50MzIsIGZsb2F0MzIsIGZsb2F0NjQsIGlzTGl0dGxlRW5kaWFuIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgeyBFbmNvZGluZyB9IGZyb20gJy4vZW5jb2RpbmcuanMnO1xuZXhwb3J0IHsgQnVpbGRlciB9IGZyb20gJy4vYnVpbGRlci5qcyc7XG5leHBvcnQgeyBCeXRlQnVmZmVyIH0gZnJvbSAnLi9ieXRlLWJ1ZmZlci5qcyc7XG4iLCJleHBvcnQgY29uc3QgaW50MzIgPSBuZXcgSW50MzJBcnJheSgyKTtcbmV4cG9ydCBjb25zdCBmbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheShpbnQzMi5idWZmZXIpO1xuZXhwb3J0IGNvbnN0IGZsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KGludDMyLmJ1ZmZlcik7XG5leHBvcnQgY29uc3QgaXNMaXR0bGVFbmRpYW4gPSBuZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkoWzEsIDBdKS5idWZmZXIpWzBdID09PSAxO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICogY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICBzdGFydCArPSBzdGVwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAqXG4gKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJhbmdlKDQpO1xuICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gKlxuICogXy5yYW5nZSgtNCk7XG4gKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAqXG4gKiBfLnJhbmdlKDEsIDUpO1xuICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gKlxuICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICpcbiAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICpcbiAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gKiAvLyA9PiBbMSwgMSwgMV1cbiAqXG4gKiBfLnJhbmdlKDApO1xuICogLy8gPT4gW11cbiAqL1xudmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByYW5nZTtcbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoV2VhdGhlckFwaSA9IHZvaWQgMDtcbmNvbnN0IGZsYXRidWZmZXJzXzEgPSByZXF1aXJlKFwiZmxhdGJ1ZmZlcnNcIik7XG5jb25zdCB3ZWF0aGVyX2FwaV9yZXNwb25zZV8xID0gcmVxdWlyZShcIkBvcGVubWV0ZW8vc2RrL3dlYXRoZXItYXBpLXJlc3BvbnNlXCIpO1xuY29uc3Qgc2xlZXAgPSAobXMpID0+IG5ldyBQcm9taXNlKHIgPT4gc2V0VGltZW91dChyLCBtcykpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyaWVkKHVybF8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qICh1cmwsIHJldHJpZXMgPSAzLCBiYWNrb2ZmRmFjdG9yID0gMC41LCBiYWNrb2ZmTWF4ID0gMikge1xuICAgICAgICBjb25zdCBzdGF0dXNUb1JldHJ5ID0gWzUwMCwgNTAyLCA1MDRdO1xuICAgICAgICBjb25zdCBzdGF0dXNXaXRoSnNvbkVycm9yID0gWzQwMCwgNDI5XTtcbiAgICAgICAgbGV0IGN1cnJlbnRUcnkgPSAwO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh1cmwpO1xuICAgICAgICB3aGlsZSAoc3RhdHVzVG9SZXRyeS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICBjdXJyZW50VHJ5Kys7XG4gICAgICAgICAgICBpZiAoY3VycmVudFRyeSA+PSByZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2xlZXBNcyA9IE1hdGgubWluKGJhY2tvZmZGYWN0b3IgKiBNYXRoLnBvdygyLCBjdXJyZW50VHJ5KSwgYmFja29mZk1heCkgKiAxMDAwO1xuICAgICAgICAgICAgeWllbGQgc2xlZXAoc2xlZXBNcyk7XG4gICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIGZldGNoKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1c1dpdGhKc29uRXJyb3IuaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGlmICgncmVhc29uJyBpbiBqc29uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGpzb24ucmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHJpZXZlIGRhdGEgZnJvbSB0aGUgT3Blbi1NZXRlbyB3ZWF0aGVyIEFQSVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgU2VydmVyIGFuZCBlbmRwb2ludC4gRS5nLiBcImh0dHBzOi8vYXBpLm9wZW4tbWV0ZW8uY29tL3YxL2ZvcmVjYXN0XCJcbiAqIEBwYXJhbSB7YW55fSBwYXJhbXMgVVJMIHBhcmFtZXRlciBhcyBhbiBvYmplY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcmV0cmllcz0zXSBOdW1iZXIgb2YgcmV0cmllcyBpbiBjYXNlIG9mIGFuIHNlcnZlciBlcnJvclxuICogQHBhcmFtIHtudW1iZXJ9IFtiYWNrb2ZmRmFjdG9yPTAuMl0gRXhwb25lbnRpYWwgYmFja29mZiBmYWN0b3IgdG8gaW5jcmVhc2Ugd2FpdCB0aW1lIGFmdGVyIGVhY2ggcmV0cnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYmFja29mZk1heD0yXSBNYXhpbXVtIHdhaXQgdGltZSBiZXR3ZWVuIHJldHJpZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFdlYXRoZXJBcGlSZXNwb25zZVtdPn1cbiAqL1xuZnVuY3Rpb24gZmV0Y2hXZWF0aGVyQXBpKHVybF8xLCBwYXJhbXNfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAodXJsLCBwYXJhbXMsIHJldHJpZXMgPSAzLCBiYWNrb2ZmRmFjdG9yID0gMC4yLCBiYWNrb2ZmTWF4ID0gMikge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIHVybFBhcmFtcy5zZXQoJ2Zvcm1hdCcsICdmbGF0YnVmZmVycycpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoUmV0cmllZChgJHt1cmx9PyR7dXJsUGFyYW1zLnRvU3RyaW5nKCl9YCwgcmV0cmllcywgYmFja29mZkZhY3RvciwgYmFja29mZk1heCk7XG4gICAgICAgIGNvbnN0IGZiID0gbmV3IGZsYXRidWZmZXJzXzEuQnl0ZUJ1ZmZlcihuZXcgVWludDhBcnJheSh5aWVsZCByZXNwb25zZS5hcnJheUJ1ZmZlcigpKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIHdoaWxlIChwb3MgPCBmYi5jYXBhY2l0eSgpKSB7XG4gICAgICAgICAgICBmYi5zZXRQb3NpdGlvbihwb3MpO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gZmIucmVhZEludDMyKGZiLnBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHdlYXRoZXJfYXBpX3Jlc3BvbnNlXzEuV2VhdGhlckFwaVJlc3BvbnNlLmdldFNpemVQcmVmaXhlZFJvb3RBc1dlYXRoZXJBcGlSZXNwb25zZShmYikpO1xuICAgICAgICAgICAgcG9zICs9IGxlbiArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoV2VhdGhlckFwaSA9IGZldGNoV2VhdGhlckFwaTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2dhdWdlXCIpO1xuIiwiLyogZ2xvYmFsIHdpbmRvdywgZGVmaW5lLCBtb2R1bGUgKi9cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdmFyIEdhdWdlID0gZmFjdG9yeShnbG9iYWwpO1xuICBpZih0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRCBzdXBwb3J0XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge3JldHVybiBHYXVnZTt9KTtcbiAgfWVsc2UgaWYodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIENvbW1vbkpTIHN1cHBvcnRcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEdhdWdlO1xuICB9ZWxzZSB7XG4gICAgLy8gV2UgYXJlIHByb2JhYmx5IHJ1bm5pbmcgaW4gdGhlIGJyb3dzZXJcbiAgICBnbG9iYWwuR2F1Z2UgPSBHYXVnZTtcbiAgfVxufSkodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiB3aW5kb3csIGZ1bmN0aW9uKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG5cbiAgdmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50LFxuICAgIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIGdsb2JhbC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgZ2xvYmFsLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICBnbG9iYWwubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChjYiwgMTAwMCAvIDYwKTtcbiAgICAgICAgfSk7XG5cbiAgLy8gRVhQRVJJTUVOVEFMISFcbiAgLyoqXG4gICAqIFNpbXBsaXN0aWMgYW5pbWF0aW9uIGZ1bmN0aW9uIGZvciBhbmltYXRpbmcgdGhlIGdhdWdlLiBUaGF0J3MgYWxsIVxuICAgKiBPcHRpb25zIGFyZTpcbiAgICoge1xuICAgKiAgZHVyYXRpb246IDEsICAgIC8vIEluIHNlY29uZHNcbiAgICogIHN0YXJ0OiAwLCAgICAgICAvLyBUaGUgc3RhcnQgdmFsdWVcbiAgICogIGVuZDogMTAwLCAgICAgICAvLyBUaGUgZW5kIHZhbHVlXG4gICAqICBzdGVwOiBmdW5jdGlvbiwgLy8gUkVRVUlSRUQhIFRoZSBzdGVwIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBwYXNzZWQgdGhlIHZhbHVlIGFuZCBkb2VzIHNvbWV0aGluZ1xuICAgKiAgZWFzaW5nOiBmdW5jdGlvbiAvLyBUaGUgZWFzaW5nIGZ1bmN0aW9uLiBEZWZhdWx0IGlzIGVhc2VJbk91dEN1YmljXG4gICAqIH1cbiAgICovXG4gIGZ1bmN0aW9uIEFuaW1hdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgY3VycmVudEl0ZXJhdGlvbiA9IDEsXG4gICAgICAgIGl0ZXJhdGlvbnMgPSA2MCAqIGR1cmF0aW9uLFxuICAgICAgICBzdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgMCxcbiAgICAgICAgZW5kID0gb3B0aW9ucy5lbmQsXG4gICAgICAgIGNoYW5nZSA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICBzdGVwID0gb3B0aW9ucy5zdGVwLFxuICAgICAgICBlYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCBmdW5jdGlvbiBlYXNlSW5PdXRDdWJpYyhwb3MpIHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGFucm8vZWFzaW5nLWpzL2Jsb2IvbWFzdGVyL2Vhc2luZy5qc1xuICAgICAgICAgIGlmICgocG9zLz0wLjUpIDwgMSkgcmV0dXJuIDAuNSpNYXRoLnBvdyhwb3MsMyk7XG4gICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnBvdygocG9zLTIpLDMpICsgMik7XG4gICAgICAgIH07XG5cbiAgICBmdW5jdGlvbiBhbmltYXRlKCkge1xuICAgICAgdmFyIHByb2dyZXNzID0gY3VycmVudEl0ZXJhdGlvbiAvIGl0ZXJhdGlvbnMsIFxuICAgICAgICAgIHZhbHVlID0gY2hhbmdlICogZWFzaW5nKHByb2dyZXNzKSArIHN0YXJ0O1xuICAgICAgLy8gY29uc29sZS5sb2cocHJvZ3Jlc3MgKyBcIiwgXCIgKyB2YWx1ZSk7XG4gICAgICBzdGVwKHZhbHVlLCBjdXJyZW50SXRlcmF0aW9uKTtcbiAgICAgIGN1cnJlbnRJdGVyYXRpb24gKz0gMTtcblxuICAgICAgaWYocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc3RhcnQhXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICB9XG5cblxuXG4gIHZhciBHYXVnZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuXG4gICAgdmFyIEdhdWdlRGVmYXVsdHMgPSB7XG4gICAgICBjZW50ZXJYOiA1MCxcbiAgICAgIGNlbnRlclk6IDUwXG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGRpYWxSYWRpdXM6IDQwLFxuICAgICAgZGlhbFN0YXJ0QW5nbGU6IDEzNSxcbiAgICAgIGRpYWxFbmRBbmdsZTogNDUsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIG1heDogMTAwLFxuICAgICAgbWluOiAwLFxuICAgICAgdmFsdWVEaWFsQ2xhc3M6IFwidmFsdWVcIixcbiAgICAgIHZhbHVlQ2xhc3M6IFwidmFsdWUtdGV4dFwiLFxuICAgICAgZGlhbENsYXNzOiBcImRpYWxcIixcbiAgICAgIGdhdWdlQ2xhc3M6IFwiZ2F1Z2VcIixcbiAgICAgIHNob3dWYWx1ZTogdHJ1ZSxcbiAgICAgIGdhdWdlQ29sb3I6IG51bGwsXG4gICAgICBsYWJlbDogZnVuY3Rpb24odmFsKSB7cmV0dXJuIE1hdGgucm91bmQodmFsKTt9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNoYWxsb3dDb3B5KC8qIHNvdXJjZSwgLi4udGFyZ2V0cyovKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzWzBdLCBzb3VyY2VzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgZm9yKHZhciBrIGluIHMpIHtcbiAgICAgICAgICBpZihzLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICB0YXJnZXRba10gPSBzW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjcmVhdGUgU1ZHIGRvbSB0cmVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIFNWRyBlbGVtZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgYXMgdGhleSBhcHBlYXIgaW4gRE9NIGUuZy4gc3Ryb2tlLXdpZHRoIGFuZCBub3Qgc3Ryb2tlV2lkdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjaGlsZHJlbiBBbiBhcnJheSBvZiBjaGlsZHJlbiAoY2FuIGJlIGNyZWF0ZWQgYnkgdGhpcyBzYW1lIGZ1bmN0aW9uKVxuICAgICAqIEByZXR1cm4gVGhlIFNWRyBlbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ZnKG5hbWUsIGF0dHJzLCBjaGlsZHJlbikge1xuICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBuYW1lKTtcbiAgICAgIGZvcih2YXIgYXR0ck5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJzW2F0dHJOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGNoaWxkcmVuKSB7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBwZXJjZW50YWdlIHZhbHVlIHRvIGFuZ2xlLiBlLmcuIElmIGdhdWdlIHNwYW4gYW5nbGUgaXMgMTgwZGVnLCB0aGVuIDUwJVxuICAgICAqIHdpbGwgYmUgOTBkZWdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbmdsZShwZXJjZW50YWdlLCBnYXVnZVNwYW5BbmdsZSkge1xuICAgICAgcmV0dXJuIHBlcmNlbnRhZ2UgKiBnYXVnZVNwYW5BbmdsZSAvIDEwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemUodmFsdWUsIG1pbiwgbGltaXQpIHtcbiAgICAgIHZhciB2YWwgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgaWYodmFsID4gbGltaXQpIHJldHVybiBsaW1pdDtcbiAgICAgIGlmKHZhbCA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVJblBlcmNlbnRhZ2UodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICB2YXIgbmV3TWF4ID0gbWF4IC0gbWluLCBuZXdWYWwgPSB2YWx1ZSAtIG1pbjtcbiAgICAgIHJldHVybiAxMDAgKiBuZXdWYWwgLyBuZXdNYXg7XG4gICAgICAvLyB2YXIgYWJzTWluID0gTWF0aC5hYnMobWluKTtcbiAgICAgIC8vIHJldHVybiAxMDAgKiAoYWJzTWluICsgdmFsdWUpIC8gKG1heCArIGFic01pbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYXJ0ZXNpYW4gY28tb3JkaW5hdGVzIGZvciBhIHNwZWNpZmllZCByYWRpdXMgYW5kIGFuZ2xlIChpbiBkZWdyZWVzKVxuICAgICAqIEBwYXJhbSBjeCB7TnVtYmVyfSBUaGUgY2VudGVyIHggY28tb3JpaW5hdGVcbiAgICAgKiBAcGFyYW0gY3kge051bWJlcn0gVGhlIGNlbnRlciB5IGNvLW9yZGluYXRlXG4gICAgICogQHBhcmFtIHJhZGl1cyB7TnVtYmVyfSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0gYW5nbGUge051bWJlcn0gVGhlIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcmV0dXJuIEFuIG9iamVjdCB3aXRoIHgseSBjby1vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDYXJ0ZXNpYW4oY3gsIGN5LCByYWRpdXMsIGFuZ2xlKSB7XG4gICAgICB2YXIgcmFkID0gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5yb3VuZCgoY3ggKyByYWRpdXMgKiBNYXRoLmNvcyhyYWQpKSAqIDEwMDApIC8gMTAwMCxcbiAgICAgICAgeTogTWF0aC5yb3VuZCgoY3kgKyByYWRpdXMgKiBNYXRoLnNpbihyYWQpKSAqIDEwMDApIC8gMTAwMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm5zIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGZvciBkaWFsXG4gICAgLy8gaS5lLiBzdGFydHMgYXQgMTM1ZGVnIGVuZHMgYXQgNDVkZWcgd2l0aCBsYXJnZSBhcmMgZmxhZ1xuICAgIC8vIFJFTUVNQkVSISEgYW5nbGU9MCBzdGFydHMgb24gWCBheGlzIGFuZCB0aGVuIGluY3JlYXNlcyBjbG9ja3dpc2VcbiAgICBmdW5jdGlvbiBnZXREaWFsQ29vcmRzKHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgICAgIHZhciBjeCA9IEdhdWdlRGVmYXVsdHMuY2VudGVyWCxcbiAgICAgICAgICBjeSA9IEdhdWdlRGVmYXVsdHMuY2VudGVyWTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVuZDogZ2V0Q2FydGVzaWFuKGN4LCBjeSwgcmFkaXVzLCBlbmRBbmdsZSksXG4gICAgICBcdHN0YXJ0OiBnZXRDYXJ0ZXNpYW4oY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBHYXVnZSBvYmplY3QuIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCB3aXRob3V0IHRoZSAnbmV3JyBvcGVyYXRvci4gVmFyaW91cyBvcHRpb25zXG4gICAgICogY2FuIGJlIHBhc3NlZCBmb3IgdGhlIGdhdWdlOlxuICAgICAqIHtcbiAgICAgKiAgICBkaWFsU3RhcnRBbmdsZTogVGhlIGFuZ2xlIHRvIHN0YXJ0IHRoZSBkaWFsLiBNVVNUIGJlIGdyZWF0ZXIgdGhhbiBkaWFsRW5kQW5nbGUuIERlZmF1bHQgMTM1ZGVnXG4gICAgICogICAgZGlhbEVuZEFuZ2xlOiBUaGUgYW5nbGUgdG8gZW5kIHRoZSBkaWFsLiBEZWZhdWx0IDQ1ZGVnXG4gICAgICogICAgZGlhbFJhZGl1czogVGhlIGdhdWdlJ3MgcmFkaXVzLiBEZWZhdWx0IDQwMFxuICAgICAqICAgIG1heDogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIGdhdWdlLiBEZWZhdWx0IDEwMFxuICAgICAqICAgIHZhbHVlOiBUaGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGdhdWdlLiBEZWZhdWx0IDBcbiAgICAgKiAgICBsYWJlbDogVGhlIGZ1bmN0aW9uIG9uIGhvdyB0byByZW5kZXIgdGhlIGNlbnRlciBsYWJlbCAoU2hvdWxkIHJldHVybiBhIHZhbHVlKVxuICAgICAqIH1cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gVGhlIERPTSBpbnRvIHdoaWNoIHRvIHJlbmRlciB0aGUgZ2F1Z2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBUaGUgZ2F1Z2Ugb3B0aW9uc1xuICAgICAqIEByZXR1cm4gYSBHYXVnZSBvYmplY3RcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gR2F1Z2UoZWxlbSwgb3B0cykge1xuICAgICAgb3B0cyA9IHNoYWxsb3dDb3B5KHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0cyk7XG4gICAgICB2YXIgZ2F1Z2VDb250YWluZXIgPSBlbGVtLFxuICAgICAgICAgIGxpbWl0ID0gb3B0cy5tYXgsXG4gICAgICAgICAgbWluID0gb3B0cy5taW4sXG4gICAgICAgICAgdmFsdWUgPSBub3JtYWxpemUob3B0cy52YWx1ZSwgbWluLCBsaW1pdCksXG4gICAgICAgICAgcmFkaXVzID0gb3B0cy5kaWFsUmFkaXVzLFxuICAgICAgICAgIGRpc3BsYXlWYWx1ZSA9IG9wdHMuc2hvd1ZhbHVlLFxuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBvcHRzLmRpYWxTdGFydEFuZ2xlLFxuICAgICAgICAgIGVuZEFuZ2xlID0gb3B0cy5kaWFsRW5kQW5nbGUsXG4gICAgICAgICAgdmFsdWVEaWFsQ2xhc3MgPSBvcHRzLnZhbHVlRGlhbENsYXNzLFxuICAgICAgICAgIHZhbHVlVGV4dENsYXNzID0gb3B0cy52YWx1ZUNsYXNzLFxuICAgICAgICAgIHZhbHVlTGFiZWxDbGFzcyA9IG9wdHMudmFsdWVMYWJlbENsYXNzLFxuICAgICAgICAgIGRpYWxDbGFzcyA9IG9wdHMuZGlhbENsYXNzLFxuICAgICAgICAgIGdhdWdlQ2xhc3MgPSBvcHRzLmdhdWdlQ2xhc3MsXG4gICAgICAgICAgZ2F1Z2VDb2xvciA9IG9wdHMuY29sb3IsXG4gICAgICAgICAgZ2F1Z2VWYWx1ZUVsZW0sXG4gICAgICAgICAgZ2F1Z2VWYWx1ZVBhdGgsXG4gICAgICAgICAgbGFiZWwgPSBvcHRzLmxhYmVsLFxuICAgICAgICAgIHZpZXdCb3ggPSBvcHRzLnZpZXdCb3gsXG4gICAgICAgICAgaW5zdGFuY2U7XG5cbiAgICAgIGlmKHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIldBUk4hIHN0YXJ0QW5nbGUgPCBlbmRBbmdsZSwgU3dhcHBpbmdcIik7XG4gICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgIGVuZEFuZ2xlID0gdG1wO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXRoU3RyaW5nKHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGxhcmdlQXJjKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBnZXREaWFsQ29vcmRzKHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUpLFxuICAgICAgICAgICAgc3RhcnQgPSBjb29yZHMuc3RhcnQsXG4gICAgICAgICAgICBlbmQgPSBjb29yZHMuZW5kLFxuICAgICAgICAgICAgbGFyZ2VBcmNGbGFnID0gdHlwZW9mKGxhcmdlQXJjKSA9PT0gXCJ1bmRlZmluZWRcIiA/IDEgOiBsYXJnZUFyYztcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiTVwiLCBzdGFydC54LCBzdGFydC55LCBcbiAgICAgICAgICBcIkFcIiwgcmFkaXVzLCByYWRpdXMsIDAsIGxhcmdlQXJjRmxhZywgMSwgZW5kLngsIGVuZC55XG4gICAgICAgIF0uam9pbihcIiBcIik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGluaXRpYWxpemVHYXVnZShlbGVtKSB7XG4gICAgICAgIGdhdWdlVmFsdWVFbGVtID0gc3ZnKFwidGV4dFwiLCB7XG4gICAgICAgICAgeDogNTAsXG4gICAgICAgICAgeTogNTAsXG4gICAgICAgICAgZmlsbDogXCIjOTk5XCIsXG4gICAgICAgICAgXCJjbGFzc1wiOiB2YWx1ZVRleHRDbGFzcyxcbiAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjEwMCVcIixcbiAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IFwic2Fucy1zZXJpZlwiLFxuICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogXCJub3JtYWxcIixcbiAgICAgICAgICBcInRleHQtYW5jaG9yXCI6IFwibWlkZGxlXCIsXG4gICAgICAgICAgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIjogXCJtaWRkbGVcIixcbiAgICAgICAgICBcImRvbWluYW50LWJhc2VsaW5lXCI6IFwiY2VudHJhbFwiXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdhdWdlVmFsdWVQYXRoID0gc3ZnKFwicGF0aFwiLCB7XG4gICAgICAgICAgXCJjbGFzc1wiOiB2YWx1ZURpYWxDbGFzcyxcbiAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgICBzdHJva2U6IFwiIzY2NlwiLFxuICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDIuNSxcbiAgICAgICAgICBkOiBwYXRoU3RyaW5nKHJhZGl1cywgc3RhcnRBbmdsZSwgc3RhcnRBbmdsZSkgLy8gdmFsdWUgb2YgMFxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgYW5nbGUgPSBnZXRBbmdsZSgxMDAsIDM2MCAtIE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSkpO1xuICAgICAgICB2YXIgZmxhZyA9IGFuZ2xlIDw9IDE4MCA/IDAgOiAxO1xuICAgICAgICB2YXIgZ2F1Z2VFbGVtZW50ID0gc3ZnKFwic3ZnXCIsIHtcInZpZXdCb3hcIjogdmlld0JveCB8fCBcIjAgMCAxMDAgMTAwXCIsIFwiY2xhc3NcIjogZ2F1Z2VDbGFzc30sIFtcbiAgICAgICAgICBzdmcoXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIFwiY2xhc3NcIjogZGlhbENsYXNzLFxuICAgICAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgICAgICBzdHJva2U6IFwiI2VlZVwiLFxuICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMixcbiAgICAgICAgICAgIGQ6IHBhdGhTdHJpbmcocmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZmxhZylcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzdmcoXCJnXCIsIHsgXCJjbGFzc1wiOiBcInRleHQtY29udGFpbmVyXCIgfSwgW2dhdWdlVmFsdWVFbGVtXSksXG4gICAgICAgICAgZ2F1Z2VWYWx1ZVBhdGhcbiAgICAgICAgXSk7XG4gICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoZ2F1Z2VFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlR2F1Z2UodGhlVmFsdWUsIGZyYW1lKSB7XG4gICAgICAgIHZhciB2YWwgPSBnZXRWYWx1ZUluUGVyY2VudGFnZSh0aGVWYWx1ZSwgbWluLCBsaW1pdCksXG4gICAgICAgICAgICAvLyBhbmdsZSA9IGdldEFuZ2xlKHZhbCwgMzYwIC0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSksXG4gICAgICAgICAgICBhbmdsZSA9IGdldEFuZ2xlKHZhbCwgMzYwIC0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSksXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2Ugd2UgYXJlIHVzaW5nIGFyYyBncmVhdGVyIHRoYW4gMTgwZGVnXG4gICAgICAgICAgICBmbGFnID0gYW5nbGUgPD0gMTgwID8gMCA6IDE7XG4gICAgICAgIGlmKGRpc3BsYXlWYWx1ZSkge1xuICAgICAgICAgIGdhdWdlVmFsdWVFbGVtLnRleHRDb250ZW50ID0gbGFiZWwuY2FsbChvcHRzLCB0aGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2F1Z2VWYWx1ZVBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCBwYXRoU3RyaW5nKHJhZGl1cywgc3RhcnRBbmdsZSwgYW5nbGUgKyBzdGFydEFuZ2xlLCBmbGFnKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldEdhdWdlQ29sb3IodmFsdWUsIGR1cmF0aW9uKSB7ICAgICAgICBcbiAgICAgICAgdmFyIGMgPSBnYXVnZUNvbG9yLmNhbGwob3B0cywgdmFsdWUpLCBcbiAgICAgICAgICAgIGR1ciA9IGR1cmF0aW9uICogMTAwMCxcbiAgICAgICAgICAgIHBhdGhUcmFuc2l0aW9uID0gXCJzdHJva2UgXCIgKyBkdXIgKyBcIm1zIGVhc2VcIjtcbiAgICAgICAgICAgIC8vIHRleHRUcmFuc2l0aW9uID0gXCJmaWxsIFwiICsgZHVyICsgXCJtcyBlYXNlXCI7XG5cbiAgICAgICAgZ2F1Z2VWYWx1ZVBhdGguc3R5bGUuc3Ryb2tlID0gYztcbiAgICAgICAgZ2F1Z2VWYWx1ZVBhdGguc3R5bGVbXCItd2Via2l0LXRyYW5zaXRpb25cIl0gPSBwYXRoVHJhbnNpdGlvbjtcbiAgICAgICAgZ2F1Z2VWYWx1ZVBhdGguc3R5bGVbXCItbW96LXRyYW5zaXRpb25cIl0gPSBwYXRoVHJhbnNpdGlvbjtcbiAgICAgICAgZ2F1Z2VWYWx1ZVBhdGguc3R5bGUudHJhbnNpdGlvbiA9IHBhdGhUcmFuc2l0aW9uO1xuICAgICAgICAvKlxuICAgICAgICBnYXVnZVZhbHVlRWxlbS5zdHlsZSA9IFtcbiAgICAgICAgICBcImZpbGw6IFwiICsgYyxcbiAgICAgICAgICBcIi13ZWJraXQtdHJhbnNpdGlvbjogXCIgKyB0ZXh0VHJhbnNpdGlvbixcbiAgICAgICAgICBcIi1tb3otdHJhbnNpdGlvbjogXCIgKyB0ZXh0VHJhbnNpdGlvbixcbiAgICAgICAgICBcInRyYW5zaXRpb246IFwiICsgdGV4dFRyYW5zaXRpb24sXG4gICAgICAgIF0uam9pbihcIjtcIik7XG4gICAgICAgICovXG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlID0ge1xuICAgICAgICBzZXRNYXhWYWx1ZTogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgICAgbGltaXQgPSBtYXg7XG4gICAgICAgICAgdXBkYXRlR2F1Z2UodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgdmFsdWUgPSBub3JtYWxpemUodmFsLCBtaW4sIGxpbWl0KTtcbiAgICAgICAgICBpZihnYXVnZUNvbG9yKSB7XG4gICAgICAgICAgICBzZXRHYXVnZUNvbG9yKHZhbHVlLCAwKVxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVHYXVnZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldFZhbHVlQW5pbWF0ZWQ6IGZ1bmN0aW9uKHZhbCwgZHVyYXRpb24pIHtcbiAgICAgICAgXHR2YXIgb2xkVmFsID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWUgPSBub3JtYWxpemUodmFsLCBtaW4sIGxpbWl0KTtcbiAgICAgICAgICBpZihvbGRWYWwgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoZ2F1Z2VDb2xvcikge1xuICAgICAgICAgICAgc2V0R2F1Z2VDb2xvcih2YWx1ZSwgZHVyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBBbmltYXRpb24oe1xuICAgICAgICAgICAgc3RhcnQ6IG9sZFZhbCB8fCAwLFxuICAgICAgICAgICAgZW5kOiB2YWx1ZSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCAxLFxuICAgICAgICAgICAgc3RlcDogZnVuY3Rpb24odmFsLCBmcmFtZSkge1xuICAgICAgICAgICAgICB1cGRhdGVHYXVnZSh2YWwsIGZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaW5pdGlhbGl6ZUdhdWdlKGdhdWdlQ29udGFpbmVyKTtcbiAgICAgIGluc3RhbmNlLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIHJldHVybiBHYXVnZTtcbn0pO1xuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzICovXG5pbXBvcnQgJ25vcm1hbGl6ZS5jc3MnO1xuaW1wb3J0ICcuL2luZGV4LXN0eWxlLmNzcyc7XG5pbXBvcnQgZ2V0TG9jYXRpb25EYXRhIGZyb20gJy4vbW9kdWxlcy93ZWF0aGVyJztcbmltcG9ydCB1cGRhdGVXZWF0aGVySW5mbyBmcm9tICcuL21vZHVsZXMvZG9tQ29udHJvbGxlcic7XG5cbmNvbnN0IGxvY2F0aW9uRGF0YSA9IGdldExvY2F0aW9uRGF0YSgncG9zdG9qbmEnKTtcbmxvY2F0aW9uRGF0YS50aGVuKChyZXMpID0+IGNvbnNvbGUubG9nKHJlcykpO1xubG9jYXRpb25EYXRhLnRoZW4oKHJlcykgPT4gdXBkYXRlV2VhdGhlckluZm8ocmVzLCAnbWV0cmljJykpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbG9uZWx5LWlmICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wbHVzcGx1cyAqL1xuaW1wb3J0ICcuLi9zdHlsZXMvaG91cmx5LWZvcmVjYXN0LXN0eWxlLmNzcyc7XG5pbXBvcnQgJy4uL3N0eWxlcy9kYWlseS1mb3JlY2FzdC1zdHlsZS5jc3MnO1xuaW1wb3J0ICcuLi9zdHlsZXMvZmVlbHMtbGlrZS1zdHlsZS5jc3MnO1xuaW1wb3J0ICcuLi9zdHlsZXMvdXYtaW5kZXgtc3R5bGUuY3NzJztcbmltcG9ydCAnLi4vc3R5bGVzL3N1bnJpc2Utc3Vuc2V0LXN0eWxlLmNzcyc7XG5pbXBvcnQgJy4uL3N0eWxlcy93aW5kLXN0eWxlLmNzcyc7XG5pbXBvcnQgJy4uL3N0eWxlcy9wcmVzc3VyZS1zdHlsZS5jc3MnO1xuaW1wb3J0IHN1bnNldCBmcm9tICcuLi9hc3NldHMvaWNvbnMvc3Vuc2V0LnN2Zyc7XG5pbXBvcnQgc3VucmlzZSBmcm9tICcuLi9hc3NldHMvaWNvbnMvc3VucmlzZS5zdmcnO1xuaW1wb3J0IHdlYXRoZXJDb2RlcyBmcm9tICcuLi9hc3NldHMvanNvbi93ZWF0aGVyQ29kZXMuanNvbic7XG5pbXBvcnQgY3JlYXRlVGVtcEJhckVsZW1lbnQgZnJvbSAnLi90ZW1wQmFyJztcbmltcG9ydCBmb3JtYXREYXRlVGltZXpvbmUgZnJvbSAnLi90aW1lem9uZUZvcm1hdHRlcic7XG5pbXBvcnQgcHJlc3N1cmVHYXVnZSBmcm9tICcuL3ByZXNzdXJlR2F1Z2UnO1xuXG5jb25zdCBkZWdyZWVJY29uID0gJ1xcdXswMDBCMH0nO1xuXG5jb25zdCBnZXRXZWF0aGVyVHlwZSA9ICh3ZWF0aGVyQ29kZSwgaXNEYXkpID0+IHtcbiAgICBjb25zdCBkYXlUeXBlID0gaXNEYXkgPT09IDEgPyAnZGF5JyA6ICduaWdodCc7XG5cbiAgICByZXR1cm4gd2VhdGhlckNvZGVzW3dlYXRoZXJDb2RlXVtkYXlUeXBlXTtcbn07XG5cbmNvbnN0IHVwZGF0ZUJyaWVmSW5mbyA9IChsb2NhdGlvbkRhdGEsIHN5c3RlbVR5cGUpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbkJyaWVmSW5mbyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sb2NhdGlvbi1icmllZi1pbmZvJyk7XG4gICAgY29uc3QgY2l0eUVsZW1lbnQgPSBsb2NhdGlvbkJyaWVmSW5mby5xdWVyeVNlbGVjdG9yKCcuY2l0eScpO1xuICAgIGNvbnN0IHRlbXBFbGVtZW50ID0gbG9jYXRpb25CcmllZkluZm8ucXVlcnlTZWxlY3RvcignLnRlbXAnKTtcbiAgICBjb25zdCB0eXBlRWxlbWVudCA9IGxvY2F0aW9uQnJpZWZJbmZvLnF1ZXJ5U2VsZWN0b3IoJy50eXBlJyk7XG4gICAgY29uc3QgdGVtcE1heEVsZW1lbnQgPSBsb2NhdGlvbkJyaWVmSW5mby5xdWVyeVNlbGVjdG9yKCcudGVtcC1oaWdoJyk7XG4gICAgY29uc3QgdGVtcE1pbkVsZW1lbnQgPSBsb2NhdGlvbkJyaWVmSW5mby5xdWVyeVNlbGVjdG9yKCcudGVtcC1sb3cnKTtcblxuICAgIGNvbnN0IG5hbWUgPSBsb2NhdGlvbkRhdGEubG9jYXRpb24ubmFtZS5zcGxpdCgnLCcpWzBdO1xuICAgIGNpdHlFbGVtZW50LnRleHRDb250ZW50ID0gbmFtZTtcblxuICAgIGNvbnN0IGN1cnJlbnRUZW1wID0gTWF0aC5yb3VuZChsb2NhdGlvbkRhdGEuY3VycmVudC50ZW1wZXJhdHVyZTJtKTtcbiAgICBjb25zdCB0ZW1wTWF4ID0gTWF0aC5yb3VuZChsb2NhdGlvbkRhdGEuZGFpbHkudGVtcGVyYXR1cmUybU1heFswXSk7XG4gICAgY29uc3QgdGVtcE1pbiA9IE1hdGgucm91bmQobG9jYXRpb25EYXRhLmRhaWx5LnRlbXBlcmF0dXJlMm1NaW5bMF0pO1xuXG4gICAgdGVtcEVsZW1lbnQudGV4dENvbnRlbnQgPSBzeXN0ZW1UeXBlID09PSAnbWV0cmljJyA/IGAke2N1cnJlbnRUZW1wfSR7ZGVncmVlSWNvbn1gIDogTWF0aC5yb3VuZChgJHtjdXJyZW50VGVtcH0ke2RlZ3JlZUljb259YCAqICg5IC8gNSkpICsgMzI7XG4gICAgdGVtcE1heEVsZW1lbnQudGV4dENvbnRlbnQgPSBzeXN0ZW1UeXBlID09PSAnbWV0cmljJyA/IGAke3RlbXBNYXh9JHtkZWdyZWVJY29ufWAgOiBNYXRoLnJvdW5kKGAke3RlbXBNYXh9JHtkZWdyZWVJY29ufWAgKiAoOSAvIDUpKSArIDMyO1xuICAgIHRlbXBNaW5FbGVtZW50LnRleHRDb250ZW50ID0gc3lzdGVtVHlwZSA9PT0gJ21ldHJpYycgPyBgJHt0ZW1wTWlufSR7ZGVncmVlSWNvbn1gIDogTWF0aC5yb3VuZChgJHt0ZW1wTWlufSR7ZGVncmVlSWNvbn1gICogKDkgLyA1KSkgKyAzMjtcblxuICAgIGNvbnN0IHdlYXRoZXJUeXBlID0gZ2V0V2VhdGhlclR5cGUoXG4gICAgICAgIGxvY2F0aW9uRGF0YS5jdXJyZW50LndlYXRoZXJDb2RlLFxuICAgICAgICBsb2NhdGlvbkRhdGEuY3VycmVudC5pc0RheSxcbiAgICApO1xuICAgIHR5cGVFbGVtZW50LnRleHRDb250ZW50ID0gd2VhdGhlclR5cGUuZGVzY3JpcHRpb247XG59O1xuXG5jb25zdCB1cGRhdGVIb3VybHlGb3JlY2FzdCA9IChsb2NhdGlvbkRhdGEsIHN5c3RlbVR5cGUpID0+IHtcbiAgICBjb25zdCBob3VybHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaG91cmx5LWZvcmVjYXN0Jyk7XG4gICAgY29uc3QgY2FyZCA9IGhvdXJseS5xdWVyeVNlbGVjdG9yKCcuY2FyZC1jb250ZW50Jyk7XG5cbiAgICAvLyBjcmVhdGUgZmlyc3QgZWxlbWVudCBpbiBjYXJkIGNvbnRlbnQgdG8gYmUgTm93XG4gICAgLy8gY3JlYXRlIDIzIGl0ZW1zIGZvciBuZXh0IDIzIGhvdXJzXG4gICAgLy8gdG90YWwgMjQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ2pzLWhvdXItaXRlbScpO1xuXG4gICAgICAgIGNvbnN0IGhvdXJUaW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBob3VyVGltZS5jbGFzc0xpc3QuYWRkKCdqcy1ob3VyLXRpbWUnKTtcbiAgICAgICAgY29uc3QgaG91ciA9IGkgPT09IDAgPyAnTm93JyA6IG5ldyBEYXRlKGxvY2F0aW9uRGF0YS5ob3VybHkudGltZVtpXSkuZ2V0SG91cnMoKTtcbiAgICAgICAgaG91clRpbWUudGV4dENvbnRlbnQgPSBob3VyO1xuICAgICAgICBjb25zdCBob3VyV2VhdGhlclR5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaG91cldlYXRoZXJUeXBlLmNsYXNzTGlzdC5hZGQoJ2pzLWhvdXItd2VhdGhlci10eXBlJyk7XG4gICAgICAgIGhvdXJXZWF0aGVyVHlwZS5zZXRBdHRyaWJ1dGUoJ2FsdCcsICdXZWF0aGVyIHR5cGUgaWNvbicpO1xuICAgICAgICBob3VyV2VhdGhlclR5cGUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMjQnKTtcbiAgICAgICAgY29uc3Qgd2VhdGhlclR5cGUgPSBnZXRXZWF0aGVyVHlwZShcbiAgICAgICAgICAgIGxvY2F0aW9uRGF0YS5ob3VybHkud2VhdGhlckNvZGVbaV0sXG4gICAgICAgICAgICBsb2NhdGlvbkRhdGEuaG91cmx5LmlzRGF5W2ldLFxuICAgICAgICApO1xuICAgICAgICBob3VyV2VhdGhlclR5cGUuc3JjID0gd2VhdGhlclR5cGUuaW1hZ2U7XG4gICAgICAgIGNvbnN0IGhvdXJUZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBob3VyVGVtcC5jbGFzc0xpc3QuYWRkKCdqcy1ob3VyLXRlbXAnKTtcbiAgICAgICAgY29uc3QgdGVtcCA9IHN5c3RlbVR5cGUgPT09ICdtZXRyaWMnID8gTWF0aC5yb3VuZChsb2NhdGlvbkRhdGEuaG91cmx5LnRlbXBlcmF0dXJlMm1baV0pIDogTWF0aC5yb3VuZCgobG9jYXRpb25EYXRhLmhvdXJseS50ZW1wZXJhdHVyZTJtW2ldICogKDkgLyA1KSkgKyAzMik7XG4gICAgICAgIGhvdXJUZW1wLnRleHRDb250ZW50ID0gYCR7dGVtcH0ke2RlZ3JlZUljb259YDtcblxuICAgICAgICBpdGVtLmFwcGVuZChob3VyVGltZSwgaG91cldlYXRoZXJUeXBlLCBob3VyVGVtcCk7XG4gICAgICAgIGNhcmQuYXBwZW5kKGl0ZW0pO1xuICAgIH1cbn07XG5cbmNvbnN0IHVwZGF0ZURhaWx5Rm9yZWNhc3QgPSAobG9jYXRpb25EYXRhLCBzeXN0ZW1UeXBlKSA9PiB7XG4gICAgY29uc3QgZGFpbHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGFpbHktZm9yZWNhc3QnKTtcbiAgICBjb25zdCBjYXJkID0gZGFpbHkucXVlcnlTZWxlY3RvcignLmNhcmQtY29udGVudCcpO1xuXG4gICAgLy8gY3JlYXRlIGZpcnN0IGVsZW1lbnQgZm9yIHRvZGF5XG4gICAgLy8gY3JlYXRlIDkgZWxlbWVudHMgZm9yIGZvbGxvd2luZyBkYXlzXG4gICAgLy8gdG90YWwgMTAgZWxlbWVudHNcbiAgICBjb25zdCB3ZWVrZGF5ID0gWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXTtcbiAgICBmb3IgKGxldCBpID0gNzsgaSA8IDE4OyBpKyspIHtcbiAgICAgICAgY29uc3QgaHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdocicpO1xuICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnanMtZGFpbHktaXRlbScpO1xuXG4gICAgICAgIGNvbnN0IGRheU5hbWVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBkYXlOYW1lRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdqcy1kYXktbmFtZScpO1xuICAgICAgICBjb25zdCBkYXkgPSBuZXcgRGF0ZShsb2NhdGlvbkRhdGEuZGFpbHkudGltZVtpXSkuZ2V0RGF5KCk7XG4gICAgICAgIGRheU5hbWVFbGVtZW50LnRleHRDb250ZW50ID0gaSA9PT0gNyA/ICdUb2RheScgOiB3ZWVrZGF5W2RheV07XG4gICAgICAgIGNvbnN0IGRhaWx5V2VhdGhlclR5cGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGRhaWx5V2VhdGhlclR5cGVFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2pzLWhvdXItd2VhdGhlci10eXBlJyk7XG4gICAgICAgIGRhaWx5V2VhdGhlclR5cGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYWx0JywgJ1dlYXRoZXIgdHlwZSBpY29uJyk7XG4gICAgICAgIGRhaWx5V2VhdGhlclR5cGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzI0Jyk7XG4gICAgICAgIGNvbnN0IHdlYXRoZXJUeXBlID0gZ2V0V2VhdGhlclR5cGUoXG4gICAgICAgICAgICBsb2NhdGlvbkRhdGEuZGFpbHkud2VhdGhlckNvZGVbaV0sXG4gICAgICAgICAgICAxLFxuICAgICAgICApO1xuICAgICAgICBkYWlseVdlYXRoZXJUeXBlRWxlbWVudC5zcmMgPSB3ZWF0aGVyVHlwZS5pbWFnZTtcbiAgICAgICAgY29uc3QgbWluVGVtcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgIGNvbnN0IG1heFRlbXBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBtaW5UZW1wRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdqcy1kYWlseS10ZW1wLW1pbicpO1xuICAgICAgICBtYXhUZW1wRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdqcy1kYWlseS10ZW1wLW1heCcpO1xuXG4gICAgICAgIGNvbnN0IG1pblRlbXAgPSBzeXN0ZW1UeXBlID09PSAnbWV0cmljJyA/IE1hdGgucm91bmQobG9jYXRpb25EYXRhLmRhaWx5LnRlbXBlcmF0dXJlMm1NaW5baV0pIDogTWF0aC5yb3VuZCgobG9jYXRpb25EYXRhLmRhaWx5LnRlbXBlcmF0dXJlMm1NaW5baV0gKiAoOSAvIDUpKSArIDMyKTtcbiAgICAgICAgbWluVGVtcEVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHttaW5UZW1wfSR7ZGVncmVlSWNvbn1gO1xuXG4gICAgICAgIGNvbnN0IG1heFRlbXAgPSBzeXN0ZW1UeXBlID09PSAnbWV0cmljJyA/IE1hdGgucm91bmQobG9jYXRpb25EYXRhLmRhaWx5LnRlbXBlcmF0dXJlMm1NYXhbaV0pIDogTWF0aC5yb3VuZCgobG9jYXRpb25EYXRhLmRhaWx5LnRlbXBlcmF0dXJlMm1NYXhbaV0gKiAoOSAvIDUpKSArIDMyKTtcbiAgICAgICAgbWF4VGVtcEVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHttYXhUZW1wfSR7ZGVncmVlSWNvbn1gO1xuXG4gICAgICAgIGNvbnN0IGJhckVsZW1lbnQgPSBjcmVhdGVUZW1wQmFyRWxlbWVudChtaW5UZW1wLCBtYXhUZW1wKTtcblxuICAgICAgICBpdGVtLmFwcGVuZChcbiAgICAgICAgICAgIGRheU5hbWVFbGVtZW50LFxuICAgICAgICAgICAgZGFpbHlXZWF0aGVyVHlwZUVsZW1lbnQsXG4gICAgICAgICAgICBtaW5UZW1wRWxlbWVudCxcbiAgICAgICAgICAgIGJhckVsZW1lbnQsXG4gICAgICAgICAgICBtYXhUZW1wRWxlbWVudCxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaSA8IDE3KSB7XG4gICAgICAgICAgICBjYXJkLmFwcGVuZChpdGVtLCBocik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYXJkLmFwcGVuZChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNvbnN0IHVwZGF0ZUZlZWxzTGlrZSA9IChsb2NhdGlvbkRhdGEsIHN5c3RlbVR5cGUpID0+IHtcbiAgICBjb25zdCBmZWVscyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5mZWVscy1saWtlJyk7XG4gICAgY29uc3QgY2FyZCA9IGZlZWxzLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkLWNvbnRlbnQnKTtcbiAgICBjb25zdCBmZWVsc0xpa2VUZW1wID0gTWF0aC5yb3VuZChsb2NhdGlvbkRhdGEuY3VycmVudC5hcHBhcmVudFRlbXBlcmF0dXJlKTtcbiAgICBjb25zdCBjdXJyZW50VGVtcCA9IE1hdGgucm91bmQobG9jYXRpb25EYXRhLmN1cnJlbnQudGVtcGVyYXR1cmUybSk7XG5cbiAgICBjb25zdCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGVtcC5jbGFzc0xpc3QuYWRkKCdqcy1mZWVscy10ZW1wJyk7XG4gICAgdGVtcC50ZXh0Q29udGVudCA9IHN5c3RlbVR5cGUgPT09ICdtZXRyaWMnID8gYCR7ZmVlbHNMaWtlVGVtcH0ke2RlZ3JlZUljb259YCA6IE1hdGgucm91bmQoYCR7ZmVlbHNMaWtlVGVtcH0ke2RlZ3JlZUljb259YCAqICg5IC8gNSkpICsgMzI7XG5cbiAgICBjb25zdCBkZXNjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVzYy5jbGFzc0xpc3QuYWRkKCdqcy1mZWVscy1kZXNjJyk7XG5cbiAgICBjb25zdCB0ZW1wRGlmID0gZmVlbHNMaWtlVGVtcCAtIGN1cnJlbnRUZW1wO1xuICAgIGlmIChzeXN0ZW1UeXBlID09PSAnbWV0cmljJykge1xuICAgICAgICBpZiAoTWF0aC5hYnModGVtcERpZikgPD0gMykgZGVzYy50ZXh0Q29udGVudCA9ICdTaW1pbGFyIHRvIHRoZSBhY3R1YWwgdGVtcGVyYXR1cmUuJztcbiAgICAgICAgZWxzZSBpZiAodGVtcERpZiA+IDMpIGRlc2MudGV4dENvbnRlbnQgPSAnSG90dGVyIHRoYW4gdGhlIGFjdHVhbCB0ZW1wZXJhdHVyZS4nO1xuICAgICAgICBlbHNlIGlmICh0ZW1wRGlmID4gLTMpIGRlc2MudGV4dENvbnRlbnQgPSAnQ29sZGVyIHRoYW4gdGhlIGFjdHVhbCB0ZW1wZXJhdHVyZS4nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh0ZW1wRGlmKSA8PSA2KSBkZXNjLnRleHRDb250ZW50ID0gJ1NpbWlsYXIgdG8gdGhlIGFjdHVhbCB0ZW1wZXJhdHVyZS4nO1xuICAgICAgICBlbHNlIGlmICh0ZW1wRGlmID4gNikgZGVzYy50ZXh0Q29udGVudCA9ICdIb3R0ZXIgdGhhbiB0aGUgYWN0dWFsIHRlbXBlcmF0dXJlLic7XG4gICAgICAgIGVsc2UgaWYgKHRlbXBEaWYgPiAtNikgZGVzYy50ZXh0Q29udGVudCA9ICdDb2xkZXIgdGhhbiB0aGUgYWN0dWFsIHRlbXBlcmF0dXJlLic7XG4gICAgfVxuXG4gICAgY2FyZC5hcHBlbmQodGVtcCwgZGVzYyk7XG59O1xuXG5jb25zdCB1cGRhdGVVdkluZGV4ID0gKGxvY2F0aW9uRGF0YSkgPT4ge1xuICAgIGNvbnN0IHV2SW5kZXggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudXYtaW5kZXgnKTtcbiAgICBjb25zdCBjYXJkID0gdXZJbmRleC5xdWVyeVNlbGVjdG9yKCcuY2FyZC1jb250ZW50Jyk7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLnJvdW5kKGxvY2F0aW9uRGF0YS5ob3VybHkudXZJbmRleFswXSk7XG5cbiAgICBjb25zdCBpbmRleERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGluZGV4RGl2LmNsYXNzTGlzdC5hZGQoJ2pzLXV2LWluZGV4Jyk7XG4gICAgY29uc3QgaW5kZXhOdW1iZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgaW5kZXhOdW1iZXIuY2xhc3NMaXN0LmFkZCgnanMtaW5kZXgnKTtcbiAgICBpbmRleE51bWJlci50ZXh0Q29udGVudCA9IGluZGV4O1xuICAgIGNvbnN0IGluZGV4U2NhbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgaW5kZXhTY2FsZS5jbGFzc0xpc3QuYWRkKCdqcy1zY2FsZScpO1xuXG4gICAgY29uc3QgaW5kZXhEZXNjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5kZXhEZXNjLmNsYXNzTGlzdC5hZGQoJ2pzLXV2LWRlc2MnKTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8PSAyKSB7XG4gICAgICAgIGluZGV4U2NhbGUudGV4dENvbnRlbnQgPSAnTm9ybWFsJztcbiAgICAgICAgaW5kZXhEZXNjLnRleHRDb250ZW50ID0gJ1lvdSBjYW4gc2FmZWx5IHN0YXkgb3V0c2lkZS4nO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gMyAmJiBpbmRleCA8PSA1KSB7XG4gICAgICAgIGluZGV4U2NhbGUudGV4dENvbnRlbnQgPSAnTW9kZXJhdGUnO1xuICAgICAgICBpbmRleERlc2MudGV4dENvbnRlbnQgPSAnVXNlIHN1biBwcm90ZWN0aW9uLic7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+PSA2ICYmIGluZGV4IDw9IDcpIHtcbiAgICAgICAgaW5kZXhTY2FsZS50ZXh0Q29udGVudCA9ICdIaWdoJztcbiAgICAgICAgaW5kZXhEZXNjLnRleHRDb250ZW50ID0gJ1VzZSBzdW4gcHJvdGVjdGlvbiBhbmQgc2VlayBzaGFkZS4nO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gOCAmJiBpbmRleCA8PSAxMCkge1xuICAgICAgICBpbmRleFNjYWxlLnRleHRDb250ZW50ID0gJ1ZlcnkgaGlnaCc7XG4gICAgICAgIGluZGV4RGVzYy50ZXh0Q29udGVudCA9ICdBdm9pZCBiZWluZyBvdXRzaWRlLic7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+PSAxMSkge1xuICAgICAgICBpbmRleFNjYWxlLnRleHRDb250ZW50ID0gJ0V4dHJlbWUnO1xuICAgICAgICBpbmRleERlc2MudGV4dENvbnRlbnQgPSAnQXZvaWQgYmVpbmcgb3V0c2lkZS4nO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4QmFyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5kZXhCYXJEaXYuY2xhc3NMaXN0LmFkZCgnanMtdXYtYmFyJyk7XG4gICAgY29uc3QgaW5kZXhCYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbmRleEJhci5jbGFzc0xpc3QuYWRkKCdqcy1iYXInKTtcbiAgICBpbmRleEJhci5zdHlsZS5sZWZ0ID0gaW5kZXggPiAxMCA/ICcxMDAlJyA6IGAke2luZGV4fTAlYDtcblxuICAgIGluZGV4RGl2LmFwcGVuZChpbmRleE51bWJlciwgaW5kZXhTY2FsZSk7XG4gICAgaW5kZXhCYXJEaXYuYXBwZW5kKGluZGV4QmFyKTtcbiAgICBjYXJkLmFwcGVuZChpbmRleERpdiwgaW5kZXhCYXJEaXYsIGluZGV4RGVzYyk7XG59O1xuXG5jb25zdCB1cGRhdGVTdW5yaXNlU3Vuc2V0ID0gKGxvY2F0aW9uRGF0YSkgPT4ge1xuICAgIGNvbnN0IHN1bnJpc2VTdW5zZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc3VucmlzZS1zdW5zZXQnKTtcbiAgICBjb25zdCBjYXJkID0gc3VucmlzZVN1bnNldC5xdWVyeVNlbGVjdG9yKCcuY2FyZC1jb250ZW50Jyk7XG4gICAgY29uc3QgdGl0bGUgPSBzdW5yaXNlU3Vuc2V0LnF1ZXJ5U2VsZWN0b3IoJy5jYXJkLXRpdGxlJyk7XG4gICAgY29uc3QgY2FyZFRpdGxlSWNvbiA9IHRpdGxlLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkLXRpdGxlLWljb24nKTtcbiAgICBjb25zdCBjYXJkVGl0bGVUZXh0ID0gdGl0bGUucXVlcnlTZWxlY3RvcignLmNhcmQtdGl0bGUtdGV4dCcpO1xuXG4gICAgY29uc3QgbWFpblRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBtYWluVGltZS5jbGFzc0xpc3QuYWRkKCdqcy1zdW5yaXNlLXN1bnNldC1tYWluLXRpbWUnKTtcbiAgICBjb25zdCBuZXh0VGltZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG5leHRUaW1lLmNsYXNzTGlzdC5hZGQoJ2pzLXN1bnJpc2Utc3Vuc2V0LW5leHQtdGltZScpO1xuXG4gICAgY29uc3QgeyB0aW1lem9uZSB9ID0gbG9jYXRpb25EYXRhLmxvY2F0aW9uO1xuICAgIGNvbnN0IHN1bnJpc2VUb2RheSA9IGxvY2F0aW9uRGF0YS5kYWlseS5zdW5yaXNlU3Vuc2V0WzBdLnN1bnJpc2U7XG4gICAgY29uc3Qgc3Vuc2V0VG9kYXkgPSBsb2NhdGlvbkRhdGEuZGFpbHkuc3VucmlzZVN1bnNldFswXS5zdW5zZXQ7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBmb3JtYXREYXRlVGltZXpvbmUodGltZXpvbmUsIG5ldyBEYXRlKCkpO1xuXG4gICAgaWYgKGN1cnJlbnRUaW1lLmdldFRpbWUoKSA+IGZvcm1hdERhdGVUaW1lem9uZSh0aW1lem9uZSwgbmV3IERhdGUoc3VucmlzZVRvZGF5KSkuZ2V0VGltZSgpXG4gICAgJiYgY3VycmVudFRpbWUuZ2V0VGltZSgpIDwgZm9ybWF0RGF0ZVRpbWV6b25lKHRpbWV6b25lLCBuZXcgRGF0ZShzdW5zZXRUb2RheSkpLmdldFRpbWUoKSkge1xuICAgICAgICBjYXJkVGl0bGVUZXh0LnRleHRDb250ZW50ID0gJ1N1bnNldCc7XG4gICAgICAgIGNhcmRUaXRsZUljb24uc3JjID0gc3Vuc2V0O1xuICAgICAgICBjYXJkVGl0bGVJY29uLmFsdCA9ICdTdW5zZXQgaWNvbic7XG4gICAgICAgIG1haW5UaW1lLnRleHRDb250ZW50ID0gc3Vuc2V0VG9kYXkuc2xpY2UoMTEsIDE2KTtcbiAgICAgICAgbmV4dFRpbWUudGV4dENvbnRlbnQgPSBgU3Vuc2V0OiAke2xvY2F0aW9uRGF0YS5kYWlseS5zdW5yaXNlU3Vuc2V0WzFdLnN1bnJpc2Uuc2xpY2UoMTEsIDE2KX1gO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgfSBlbHNlIGlmIChjdXJyZW50VGltZS5nZXRUaW1lKCkgPiBmb3JtYXREYXRlVGltZXpvbmUodGltZXpvbmUsIG5ldyBEYXRlKHN1bnJpc2VUb2RheSkpLmdldFRpbWUoKVxuICAgICYmIGN1cnJlbnRUaW1lLmdldFRpbWUoKSA+IGZvcm1hdERhdGVUaW1lem9uZSh0aW1lem9uZSwgbmV3IERhdGUoc3Vuc2V0VG9kYXkpKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgY2FyZFRpdGxlVGV4dC50ZXh0Q29udGVudCA9ICdTdW5yaXNlJztcbiAgICAgICAgY2FyZFRpdGxlSWNvbi5zcmMgPSBzdW5yaXNlO1xuICAgICAgICBjYXJkVGl0bGVJY29uLmFsdCA9ICdTdW5yaXNlIGljb24nO1xuICAgICAgICBtYWluVGltZS50ZXh0Q29udGVudCA9IGxvY2F0aW9uRGF0YS5kYWlseS5zdW5yaXNlU3Vuc2V0WzFdLnN1bnJpc2Uuc2xpY2UoMTEsIDE2KTtcbiAgICAgICAgbmV4dFRpbWUudGV4dENvbnRlbnQgPSBgU3Vuc2V0OiAke2xvY2F0aW9uRGF0YS5kYWlseS5zdW5yaXNlU3Vuc2V0WzFdLnN1bnNldC5zbGljZSgxMSwgMTYpfWA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRUaW1lLmdldFRpbWUoKSA8IGZvcm1hdERhdGVUaW1lem9uZSh0aW1lem9uZSwgbmV3IERhdGUoc3VucmlzZVRvZGF5KSkuZ2V0VGltZSgpKSB7XG4gICAgICAgIGNhcmRUaXRsZVRleHQudGV4dENvbnRlbnQgPSAnU3VucmlzZSc7XG4gICAgICAgIGNhcmRUaXRsZUljb24uc3JjID0gc3VucmlzZTtcbiAgICAgICAgY2FyZFRpdGxlSWNvbi5hbHQgPSAnU3VucmlzZSBpY29uJztcbiAgICAgICAgbWFpblRpbWUudGV4dENvbnRlbnQgPSBsb2NhdGlvbkRhdGEuZGFpbHkuc3VucmlzZVN1bnNldFswXS5zdW5yaXNlLnNsaWNlKDExLCAxNik7XG4gICAgICAgIG5leHRUaW1lLnRleHRDb250ZW50ID0gYFN1bnNldDogJHtzdW5zZXRUb2RheS5zbGljZSgxMSwgMTYpfWA7XG4gICAgfVxuXG4gICAgY2FyZC5hcHBlbmQobWFpblRpbWUsIG5leHRUaW1lKTtcbn07XG5cbmNvbnN0IHVwZGF0ZVdpbmQgPSAobG9jYXRpb25EYXRhLCBzeXN0ZW1UeXBlKSA9PiB7XG4gICAgY29uc3Qgd2luZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy53aW5kJyk7XG4gICAgY29uc3QgY2FyZCA9IHdpbmQucXVlcnlTZWxlY3RvcignLmNhcmQtY29udGVudCcpO1xuICAgIGNvbnN0IHdpbmRUeXBlID0gY2FyZC5xdWVyeVNlbGVjdG9yKCcud2luZC10eXBlLXdpbmQnKTtcbiAgICBjb25zdCB3aW5kU3BlZWQgPSB3aW5kVHlwZS5xdWVyeVNlbGVjdG9yKCcud2luZC1sZWZ0Jyk7XG4gICAgY29uc3Qgd2luZE1ldHJpYyA9IHdpbmRUeXBlLnF1ZXJ5U2VsZWN0b3IoJy53aW5kLW1ldHJpYycpO1xuICAgIGNvbnN0IGd1c3RUeXBlID0gY2FyZC5xdWVyeVNlbGVjdG9yKCcud2luZC10eXBlLWd1c3QnKTtcbiAgICBjb25zdCBndXN0U3BlZWQgPSBndXN0VHlwZS5xdWVyeVNlbGVjdG9yKCcud2luZC1sZWZ0Jyk7XG4gICAgY29uc3QgZ3VzdE1ldHJpYyA9IGd1c3RUeXBlLnF1ZXJ5U2VsZWN0b3IoJy53aW5kLW1ldHJpYycpO1xuICAgIGNvbnN0IHdpbmREaXJlY3Rpb24gPSBjYXJkLnF1ZXJ5U2VsZWN0b3IoJy53aW5kLWRpcmVjdGlvbicpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHdpbmREaXJlY3Rpb24ucXVlcnlTZWxlY3RvcigncCcpO1xuICAgIGNvbnN0IGFycm93ID0gd2luZERpcmVjdGlvbi5xdWVyeVNlbGVjdG9yKCcuYXJyb3cnKTtcblxuICAgIHdpbmRNZXRyaWMudGV4dENvbnRlbnQgPSBzeXN0ZW1UeXBlID09PSAnbWV0cmljJyA/ICdLTS9IJyA6ICdNUC9IJztcbiAgICBndXN0TWV0cmljLnRleHRDb250ZW50ID0gc3lzdGVtVHlwZSA9PT0gJ21ldHJpYycgPyAnS00vSCcgOiAnTVAvSCc7XG5cbiAgICBjb25zdCBkaXJlY3Rpb25EZWdyZWUgPSBNYXRoLnJvdW5kKGxvY2F0aW9uRGF0YS5jdXJyZW50LndpbmREaXJlY3Rpb24xMG0pO1xuICAgIGFycm93LnN0eWxlLnRyYW5zZm9ybSA9IGByb3RhdGUoJHtNYXRoLnJvdW5kKGRpcmVjdGlvbkRlZ3JlZSl9ZGVnKWA7XG5cbiAgICBpZiAoZGlyZWN0aW9uRGVncmVlID49IDMzNiB8fCBkaXJlY3Rpb25EZWdyZWUgPD0gMjQpIHtcbiAgICAgICAgZGlyZWN0aW9uLnRleHRDb250ZW50ID0gJ04nO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uRGVncmVlID49IDI1ICYmIGRpcmVjdGlvbkRlZ3JlZSA8PSA2NSkge1xuICAgICAgICBkaXJlY3Rpb24udGV4dENvbnRlbnQgPSAnTkUnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uRGVncmVlID49IDY2ICYmIGRpcmVjdGlvbkRlZ3JlZSA8PSAxMTQpIHtcbiAgICAgICAgZGlyZWN0aW9uLnRleHRDb250ZW50ID0gJ0UnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uRGVncmVlID49IDExNSAmJiBkaXJlY3Rpb25EZWdyZWUgPD0gMTU1KSB7XG4gICAgICAgIGRpcmVjdGlvbi50ZXh0Q29udGVudCA9ICdTRSc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb25EZWdyZWUgPj0gMTU2ICYmIGRpcmVjdGlvbkRlZ3JlZSA8PSAyMDQpIHtcbiAgICAgICAgZGlyZWN0aW9uLnRleHRDb250ZW50ID0gJ1MnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uRGVncmVlID49IDIwNSAmJiBkaXJlY3Rpb25EZWdyZWUgPD0gMjQ1KSB7XG4gICAgICAgIGRpcmVjdGlvbi50ZXh0Q29udGVudCA9ICdTVyc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb25EZWdyZWUgPj0gMjQ2ICYmIGRpcmVjdGlvbkRlZ3JlZSA8PSAyOTQpIHtcbiAgICAgICAgZGlyZWN0aW9uLnRleHRDb250ZW50ID0gJ1cnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uRGVncmVlID49IDI5NSAmJiBkaXJlY3Rpb25EZWdyZWUgPD0gMzM1KSB7XG4gICAgICAgIGRpcmVjdGlvbi50ZXh0Q29udGVudCA9ICdOVyc7XG4gICAgfVxuXG4gICAgd2luZFNwZWVkLnRleHRDb250ZW50ID0gc3lzdGVtVHlwZSA9PT0gJ21ldHJpYycgPyBNYXRoLnJvdW5kKGxvY2F0aW9uRGF0YS5jdXJyZW50LndpbmRTcGVlZDEwbSkgOiBNYXRoLnJvdW5kKGxvY2F0aW9uRGF0YS5jdXJyZW50LndpbmRTcGVlZDEwbSAvIDEuNjA5MzQ0KTtcbiAgICBndXN0U3BlZWQudGV4dENvbnRlbnQgPSBzeXN0ZW1UeXBlID09PSAnbWV0cmljJyA/IE1hdGgucm91bmQobG9jYXRpb25EYXRhLmN1cnJlbnQud2luZEd1c3RzMTBtKSA6IE1hdGgucm91bmQobG9jYXRpb25EYXRhLmN1cnJlbnQud2luZEd1c3RzMTBtIC8gMS42MDkzNDQpO1xufTtcblxuY29uc3QgdXBkYXRlUHJlc3N1cmUgPSAobG9jYXRpb25EYXRhKSA9PiB7XG4gICAgcHJlc3N1cmVHYXVnZShNYXRoLnJvdW5kKGxvY2F0aW9uRGF0YS5jdXJyZW50LnByZXNzdXJlTXNsKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGVXZWF0aGVySW5mbyhsb2NhdGlvbkRhdGEsIHN5c3RlbVR5cGUpIHtcbiAgICB1cGRhdGVCcmllZkluZm8obG9jYXRpb25EYXRhLCBzeXN0ZW1UeXBlKTtcbiAgICB1cGRhdGVIb3VybHlGb3JlY2FzdChsb2NhdGlvbkRhdGEsIHN5c3RlbVR5cGUpO1xuICAgIHVwZGF0ZURhaWx5Rm9yZWNhc3QobG9jYXRpb25EYXRhLCBzeXN0ZW1UeXBlKTtcbiAgICB1cGRhdGVGZWVsc0xpa2UobG9jYXRpb25EYXRhLCBzeXN0ZW1UeXBlKTtcbiAgICB1cGRhdGVVdkluZGV4KGxvY2F0aW9uRGF0YSk7XG4gICAgdXBkYXRlU3VucmlzZVN1bnNldChsb2NhdGlvbkRhdGEpO1xuICAgIHVwZGF0ZVdpbmQobG9jYXRpb25EYXRhLCBzeXN0ZW1UeXBlKTtcbiAgICB1cGRhdGVQcmVzc3VyZShsb2NhdGlvbkRhdGEpO1xufVxuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuaW1wb3J0IEdhdWdlIGZyb20gJ3N2Zy1nYXVnZSc7XG5cbi8vIENyZWF0ZSBhIG5ldyBHYXVnZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJlc3N1cmVHYXVnZSh2YWx1ZSkge1xuICAgIEdhdWdlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYXVnZTMnKSwge1xuICAgICAgICBtaW46IDk3NSxcbiAgICAgICAgbWF4OiAxMDUwLFxuICAgICAgICBsYWJlbChfdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtNYXRoLnJvdW5kKF92YWx1ZSl9YDtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZpZXdCb3g6ICcwIDAgMTAwIDEwMCcsXG4gICAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVUZW1wQmFyRWxlbWVudChfbWluVGVtcCwgX21heFRlbXApIHtcbiAgICBjb25zdCByb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignOnJvb3QnKTtcbiAgICBjb25zdCB2YXJzID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcblxuICAgIGNvbnN0IHNsaWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNsaWRlci5jbGFzc0xpc3QuYWRkKCdqcy10ZW1wLWJhcicpO1xuICAgIGNvbnN0IHByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJvZ3Jlc3MuY2xhc3NMaXN0LmFkZCgnanMtYmFyJyk7XG5cbiAgICBsZXQgbWluVGVtcDtcbiAgICBsZXQgbWF4VGVtcDtcbiAgICBpZiAoX21pblRlbXAgPj0gMjkpIHtcbiAgICAgICAgbWluVGVtcCA9IDI5O1xuICAgICAgICBtYXhUZW1wID0gNDA7XG4gICAgICAgIHByb2dyZXNzLnN0eWxlLmJhY2tncm91bmQgPSBgbGluZWFyLWdyYWRpZW50KDkwZGVnLCAke3ZhcnMuZ2V0UHJvcGVydHlWYWx1ZSgnLS05MC1wZXJjJyl9LCAke3ZhcnMuZ2V0UHJvcGVydHlWYWx1ZSgnLS0xMDAtcGVyYycpfWA7XG4gICAgfSBlbHNlIGlmIChfbWluVGVtcCA+PSAyMSkge1xuICAgICAgICBtaW5UZW1wID0gMjE7XG4gICAgICAgIGlmIChfbWF4VGVtcCA+IDMzKSB7XG4gICAgICAgICAgICBtYXhUZW1wID0gMzk7XG4gICAgICAgICAgICBwcm9ncmVzcy5zdHlsZS5iYWNrZ3JvdW5kID0gYGxpbmVhci1ncmFkaWVudCg5MGRlZywgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNzAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tODAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tOTAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMTAwLXBlcmMnKX1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF4VGVtcCA9IDMzO1xuICAgICAgICAgICAgcHJvZ3Jlc3Muc3R5bGUuYmFja2dyb3VuZCA9IGBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICR7dmFycy5nZXRQcm9wZXJ0eVZhbHVlKCctLTcwLXBlcmMnKX0sICR7dmFycy5nZXRQcm9wZXJ0eVZhbHVlKCctLTgwLXBlcmMnKX0sICR7dmFycy5nZXRQcm9wZXJ0eVZhbHVlKCctLTkwLXBlcmMnKX1gO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChfbWluVGVtcCA+PSAxMCkge1xuICAgICAgICBtaW5UZW1wID0gMTA7XG4gICAgICAgIGlmIChfbWF4VGVtcCA+IDI4KSB7XG4gICAgICAgICAgICBtYXhUZW1wID0gMzI7XG4gICAgICAgICAgICBwcm9ncmVzcy5zdHlsZS5iYWNrZ3JvdW5kID0gYGxpbmVhci1ncmFkaWVudCg5MGRlZywgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNTAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNjAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNzAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tODAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tOTAtcGVyYycpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhUZW1wID0gMjg7XG4gICAgICAgICAgICBwcm9ncmVzcy5zdHlsZS5iYWNrZ3JvdW5kID0gYGxpbmVhci1ncmFkaWVudCg5MGRlZywgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNTAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNjAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNzAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tODAtcGVyYycpfWA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9taW5UZW1wIDw9IDkpIHtcbiAgICAgICAgbWluVGVtcCA9IDA7XG4gICAgICAgIGlmIChfbWF4VGVtcCA+IDE1KSB7XG4gICAgICAgICAgICBtYXhUZW1wID0gMjc7XG4gICAgICAgICAgICBwcm9ncmVzcy5zdHlsZS5iYWNrZ3JvdW5kID0gYGxpbmVhci1ncmFkaWVudCg5MGRlZywgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMjAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMzAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNDAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNTAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNjAtcGVyYycpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhUZW1wID0gMTU7XG4gICAgICAgICAgICBwcm9ncmVzcy5zdHlsZS5iYWNrZ3JvdW5kID0gYGxpbmVhci1ncmFkaWVudCg5MGRlZywgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMjAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMzAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNDAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tNTAtcGVyYycpfWA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9taW5UZW1wIDw9IC0xKSB7XG4gICAgICAgIG1pblRlbXAgPSAtMTU7XG4gICAgICAgIGlmIChfbWF4VGVtcCA+IDApIHtcbiAgICAgICAgICAgIG1heFRlbXAgPSAwO1xuICAgICAgICAgICAgcHJvZ3Jlc3Muc3R5bGUuYmFja2dyb3VuZCA9IGBsaW5lYXItZ3JhZGllbnQoOTBkZWcsICR7dmFycy5nZXRQcm9wZXJ0eVZhbHVlKCctLTAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMTAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMjAtcGVyYycpfSwgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMzAtcGVyYycpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhUZW1wID0gLTU7XG4gICAgICAgICAgICBwcm9ncmVzcy5zdHlsZS5iYWNrZ3JvdW5kID0gYGxpbmVhci1ncmFkaWVudCg5MGRlZywgJHt2YXJzLmdldFByb3BlcnR5VmFsdWUoJy0tMC1wZXJjJyl9LCAke3ZhcnMuZ2V0UHJvcGVydHlWYWx1ZSgnLS0xMC1wZXJjJyl9LCAke3ZhcnMuZ2V0UHJvcGVydHlWYWx1ZSgnLS0yMC1wZXJjJyl9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNhbGN1bGF0ZUxlZnRQZXJjZW50ID0gX21pblRlbXAgPD0gbWluVGVtcFxuICAgICAgICA/IDBcbiAgICAgICAgOiBNYXRoLnJvdW5kKCgoX21pblRlbXAgLSBtaW5UZW1wKSAqIDEwMCkgLyAobWF4VGVtcCAtIG1pblRlbXApKTtcbiAgICBjb25zdCBjYWxjdWxhdGVSaWdodFBlcmNlbnQgPSBfbWF4VGVtcCA+PSBtYXhUZW1wXG4gICAgICAgID8gMFxuICAgICAgICA6IE1hdGgucm91bmQoMTAwIC0gKChfbWF4VGVtcCAtIG1pblRlbXApICogMTAwKSAvIChtYXhUZW1wIC0gbWluVGVtcCkpO1xuXG4gICAgcHJvZ3Jlc3Muc3R5bGUubGVmdCA9IGAke2NhbGN1bGF0ZUxlZnRQZXJjZW50fSVgO1xuICAgIHByb2dyZXNzLnN0eWxlLnJpZ2h0ID0gYCR7Y2FsY3VsYXRlUmlnaHRQZXJjZW50fSVgO1xuXG4gICAgc2xpZGVyLmFwcGVuZChwcm9ncmVzcyk7XG4gICAgcmV0dXJuIHNsaWRlcjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdERhdGVUaW1lem9uZSh0aW1lem9uZSwgZGF0ZSA9IG5ldyBEYXRlKCkpIHtcbiAgICBjb25zdCBvcHRpb25zWWVhciA9IHtcbiAgICAgICAgdGltZVpvbmU6IHRpbWV6b25lLFxuICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXR0ZXJZZWFyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoW10sIG9wdGlvbnNZZWFyKTtcbiAgICBjb25zdCBuZXdEYXRlWWVhciA9IGZvcm1hdHRlclllYXIuZm9ybWF0KGRhdGUpO1xuXG4gICAgY29uc3Qgb3B0aW9uc01vbnRoID0ge1xuICAgICAgICB0aW1lWm9uZTogdGltZXpvbmUsXG4gICAgICAgIG1vbnRoOiAnMi1kaWdpdCcsXG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXR0ZXJNb250aCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFtdLCBvcHRpb25zTW9udGgpO1xuICAgIGNvbnN0IG5ld0RhdGVNb250aCA9IGZvcm1hdHRlck1vbnRoLmZvcm1hdChkYXRlKTtcblxuICAgIGNvbnN0IG9wdGlvbnNEYXkgPSB7XG4gICAgICAgIHRpbWVab25lOiB0aW1lem9uZSxcbiAgICAgICAgZGF5OiAnMi1kaWdpdCcsXG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXR0ZXJEYXkgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChbXSwgb3B0aW9uc0RheSk7XG4gICAgY29uc3QgbmV3RGF0ZURheSA9IGZvcm1hdHRlckRheS5mb3JtYXQoZGF0ZSk7XG5cbiAgICBjb25zdCBvcHRpb25zVGltZSA9IHtcbiAgICAgICAgdGltZVpvbmU6IHRpbWV6b25lLFxuICAgICAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgICAgIG1pbnV0ZTogJ251bWVyaWMnLFxuICAgICAgICBzZWNvbmQ6ICdudW1lcmljJyxcbiAgICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGZvcm1hdHRlclRpbWUgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChbXSwgb3B0aW9uc1RpbWUpO1xuICAgIGNvbnN0IG5ld0RhdGVUaW1lID0gZm9ybWF0dGVyVGltZS5mb3JtYXQoZGF0ZSk7XG5cbiAgICBsZXQgbmV3RGF0ZSA9IGAke25ld0RhdGVZZWFyfS8ke25ld0RhdGVNb250aH0vJHtuZXdEYXRlRGF5fVQke25ld0RhdGVUaW1lfWA7XG5cbiAgICBuZXdEYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShuZXdEYXRlLnJlcGxhY2VBbGwoJy8nLCAnLScpKSk7XG4gICAgcmV0dXJuIG5ld0RhdGU7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBsdXNwbHVzICovXG5pbXBvcnQgeyBmZXRjaFdlYXRoZXJBcGkgfSBmcm9tICdvcGVubWV0ZW8nO1xuaW1wb3J0IGZvcm1hdERhdGVUaW1lem9uZSBmcm9tICcuL3RpbWV6b25lRm9ybWF0dGVyJztcblxuY29uc3QgcmFuZ2UgPSByZXF1aXJlKCdsb2Rhc2gucmFuZ2UnKTtcblxuY29uc3QgZ2V0Q29vcmRzID0gYXN5bmMgKGxvY2F0aW9uKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9nZW9jb2RpbmctYXBpLm9wZW4tbWV0ZW8uY29tL3YxL3NlYXJjaD9uYW1lPSR7bG9jYXRpb259JmNvdW50PTEmbGFuZ3VhZ2U9ZW4mZm9ybWF0PWpzb25gLCB7IG1vZGU6ICdjb3JzJyB9KTtcblxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gZGF0YS5yZXN1bHRzWzBdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbn07XG5cbmNvbnN0IGdldFN1bnJpc2VTdW5zZXQgPSBhc3luYyAobG9jYXRpb24sIHRpbWV6b25lKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHRvbW9ycm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgdG9tb3Jyb3cuc2V0RGF0ZSh0b21vcnJvdy5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgdG9tb3Jyb3cgPSBuZXcgRGF0ZSh0b21vcnJvdy50b0xvY2FsZVN0cmluZygnZW4nLCB7IHRpbWVab25lOiB0aW1lem9uZSB9KSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VUb2RheSA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS5zdW5yaXNlLXN1bnNldC5vcmcvanNvbj9sYXQ9JHtsb2NhdGlvbi5sYXRpdHVkZX0mbG5nPSR7bG9jYXRpb24ubG9uZ2l0dWRlfSZkYXRlPXRvZGF5JnR6aWQ9JHt0aW1lem9uZX0mZm9ybWF0dGVkPTBgLCB7IG1vZGU6ICdjb3JzJyB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VUb21vcnJvdyA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS5zdW5yaXNlLXN1bnNldC5vcmcvanNvbj9sYXQ9JHtsb2NhdGlvbi5sYXRpdHVkZX0mbG5nPSR7bG9jYXRpb24ubG9uZ2l0dWRlfSZkYXRlPSR7dG9tb3Jyb3cuZ2V0RnVsbFllYXIoKX0tJHt0b21vcnJvdy5nZXRNb250aCgpfS0ke3RvbW9ycm93LmdldERhdGUoKX0mdHppZD0ke3RpbWV6b25lfSZmb3JtYXR0ZWQ9MGAsIHsgbW9kZTogJ2NvcnMnIH0pO1xuXG4gICAgICAgIGNvbnN0IGRhdGFUb2RheSA9IGF3YWl0IHJlc3BvbnNlVG9kYXkuanNvbigpO1xuICAgICAgICBjb25zdCBkYXRhVG9tb3Jyb3cgPSBhd2FpdCByZXNwb25zZVRvbW9ycm93Lmpzb24oKTtcblxuICAgICAgICByZXR1cm4gW2RhdGFUb2RheS5yZXN1bHRzLCBkYXRhVG9tb3Jyb3cucmVzdWx0c107XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYXRpb25EYXRhKGxvY2F0aW9uKSB7XG4gICAgY29uc3QgbG9jYXRpb25Db29yZHMgPSBhd2FpdCBnZXRDb29yZHMobG9jYXRpb24pO1xuXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBsYXRpdHVkZTogbG9jYXRpb25Db29yZHMubGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZTogbG9jYXRpb25Db29yZHMubG9uZ2l0dWRlLFxuICAgICAgICBjdXJyZW50OiBbJ3RlbXBlcmF0dXJlXzJtJywgJ3JlbGF0aXZlX2h1bWlkaXR5XzJtJywgJ2FwcGFyZW50X3RlbXBlcmF0dXJlJywgJ3ByZWNpcGl0YXRpb24nLCAnd2VhdGhlcl9jb2RlJywgJ2lzX2RheScsICd3aW5kX3NwZWVkXzEwbScsICd3aW5kX2RpcmVjdGlvbl8xMG0nLCAnd2luZF9ndXN0c18xMG0nLCAncHJlc3N1cmVfbXNsJ10sXG4gICAgICAgIGhvdXJseTogWyd0ZW1wZXJhdHVyZV8ybScsICdwcmVjaXBpdGF0aW9uJywgJ3dlYXRoZXJfY29kZScsICd1dl9pbmRleCcsICdpc19kYXknXSxcbiAgICAgICAgZGFpbHk6IFsnd2VhdGhlcl9jb2RlJywgJ3RlbXBlcmF0dXJlXzJtX21heCcsICd0ZW1wZXJhdHVyZV8ybV9taW4nLCAndXZfaW5kZXhfbWF4J10sXG4gICAgICAgIHRpbWV6b25lOiAnYXV0bycsXG4gICAgICAgIHBhc3RfZGF5czogNyxcbiAgICAgICAgZm9yZWNhc3RfZGF5czogMTQsXG4gICAgICAgIGZvcmVjYXN0X2hvdXJzOiAyNCxcbiAgICB9O1xuXG4gICAgY29uc3QgdXJsID0gJ2h0dHBzOi8vYXBpLm9wZW4tbWV0ZW8uY29tL3YxL2ZvcmVjYXN0JztcbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBmZXRjaFdlYXRoZXJBcGkodXJsLCBwYXJhbXMpO1xuXG4gICAgLy8gUHJvY2VzcyBmaXJzdCBsb2NhdGlvblxuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVzcG9uc2VzWzBdO1xuXG4gICAgLy8gQXR0cmlidXRlcyBmb3IgdGltZXpvbmUgYW5kIGxvY2F0aW9uXG4gICAgY29uc3QgdGltZXpvbmUgPSByZXNwb25zZS50aW1lem9uZSgpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSByZXNwb25zZS5jdXJyZW50KCk7XG4gICAgY29uc3QgaG91cmx5ID0gcmVzcG9uc2UuaG91cmx5KCk7XG4gICAgY29uc3QgZGFpbHkgPSByZXNwb25zZS5kYWlseSgpO1xuXG4gICAgLy8gR2V0IHN1bnJpc2UgYW5kIHN1bnNldCBkYXRhXG4gICAgY29uc3Qgc3VucmlzZVN1bnNldCA9IGF3YWl0IGdldFN1bnJpc2VTdW5zZXQobG9jYXRpb25Db29yZHMsIHRpbWV6b25lKTtcblxuICAgIC8vIE5vdGU6IFRoZSBvcmRlciBvZiB3ZWF0aGVyIHZhcmlhYmxlcyBpbiB0aGUgVVJMIHF1ZXJ5IGFuZCB0aGUgaW5kaWNlcyBiZWxvdyBuZWVkIHRvIG1hdGNoIVxuICAgIGNvbnN0IHdlYXRoZXJEYXRhID0ge1xuICAgICAgICBsb2NhdGlvbjoge1xuICAgICAgICAgICAgbmFtZTogbG9jYXRpb25Db29yZHMubmFtZSxcbiAgICAgICAgICAgIHRpbWV6b25lOiBsb2NhdGlvbkNvb3Jkcy50aW1lem9uZSxcbiAgICAgICAgfSxcbiAgICAgICAgY3VycmVudDoge1xuICAgICAgICAgICAgdGltZTogZm9ybWF0RGF0ZVRpbWV6b25lKHRpbWV6b25lLCBuZXcgRGF0ZSgpKSxcbiAgICAgICAgICAgIHRlbXBlcmF0dXJlMm06IGN1cnJlbnQudmFyaWFibGVzKDApLnZhbHVlKCksXG4gICAgICAgICAgICByZWxhdGl2ZUh1bWlkaXR5Mm06IGN1cnJlbnQudmFyaWFibGVzKDEpLnZhbHVlKCksXG4gICAgICAgICAgICBhcHBhcmVudFRlbXBlcmF0dXJlOiBjdXJyZW50LnZhcmlhYmxlcygyKS52YWx1ZSgpLFxuICAgICAgICAgICAgcHJlY2lwaXRhdGlvbjogY3VycmVudC52YXJpYWJsZXMoMykudmFsdWUoKSxcbiAgICAgICAgICAgIHdlYXRoZXJDb2RlOiBjdXJyZW50LnZhcmlhYmxlcyg0KS52YWx1ZSgpLFxuICAgICAgICAgICAgaXNEYXk6IGN1cnJlbnQudmFyaWFibGVzKDUpLnZhbHVlKCksXG4gICAgICAgICAgICB3aW5kU3BlZWQxMG06IGN1cnJlbnQudmFyaWFibGVzKDYpLnZhbHVlKCksXG4gICAgICAgICAgICB3aW5kRGlyZWN0aW9uMTBtOiBjdXJyZW50LnZhcmlhYmxlcyg3KS52YWx1ZSgpLFxuICAgICAgICAgICAgd2luZEd1c3RzMTBtOiBjdXJyZW50LnZhcmlhYmxlcyg4KS52YWx1ZSgpLFxuICAgICAgICAgICAgcHJlc3N1cmVNc2w6IGN1cnJlbnQudmFyaWFibGVzKDkpLnZhbHVlKCksXG4gICAgICAgIH0sXG4gICAgICAgIGhvdXJseToge1xuICAgICAgICAgICAgdGltZTogcmFuZ2UoTnVtYmVyKGhvdXJseS50aW1lKCkpLCBOdW1iZXIoaG91cmx5LnRpbWVFbmQoKSksIGhvdXJseS5pbnRlcnZhbCgpKS5tYXAoXG4gICAgICAgICAgICAgICAgKHQpID0+IGZvcm1hdERhdGVUaW1lem9uZSh0aW1lem9uZSwgbmV3IERhdGUodCAqIDEwMDApKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0ZW1wZXJhdHVyZTJtOiBob3VybHkudmFyaWFibGVzKDApLnZhbHVlc0FycmF5KCksXG4gICAgICAgICAgICBwcmVjaXBpdGF0aW9uOiBob3VybHkudmFyaWFibGVzKDEpLnZhbHVlc0FycmF5KCksXG4gICAgICAgICAgICB3ZWF0aGVyQ29kZTogaG91cmx5LnZhcmlhYmxlcygyKS52YWx1ZXNBcnJheSgpLFxuICAgICAgICAgICAgdXZJbmRleDogaG91cmx5LnZhcmlhYmxlcygzKS52YWx1ZXNBcnJheSgpLFxuICAgICAgICAgICAgaXNEYXk6IGhvdXJseS52YXJpYWJsZXMoNCkudmFsdWVzQXJyYXkoKSxcbiAgICAgICAgfSxcbiAgICAgICAgZGFpbHk6IHtcbiAgICAgICAgICAgIHRpbWU6IHJhbmdlKE51bWJlcihkYWlseS50aW1lKCkpLCBOdW1iZXIoZGFpbHkudGltZUVuZCgpKSwgZGFpbHkuaW50ZXJ2YWwoKSkubWFwKFxuICAgICAgICAgICAgICAgICh0KSA9PiBmb3JtYXREYXRlVGltZXpvbmUodGltZXpvbmUsIG5ldyBEYXRlKHQgKiAxMDAwKSksXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd2VhdGhlckNvZGU6IGRhaWx5LnZhcmlhYmxlcygwKS52YWx1ZXNBcnJheSgpLFxuICAgICAgICAgICAgdGVtcGVyYXR1cmUybU1heDogZGFpbHkudmFyaWFibGVzKDEpLnZhbHVlc0FycmF5KCksXG4gICAgICAgICAgICB0ZW1wZXJhdHVyZTJtTWluOiBkYWlseS52YXJpYWJsZXMoMikudmFsdWVzQXJyYXkoKSxcbiAgICAgICAgICAgIHV2SW5kZXhNYXg6IGRhaWx5LnZhcmlhYmxlcygzKS52YWx1ZXNBcnJheSgpLFxuICAgICAgICAgICAgc3VucmlzZVN1bnNldCxcbiAgICAgICAgfSxcblxuICAgIH07XG4gICAgcmV0dXJuIHdlYXRoZXJEYXRhO1xufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCJ2YXIgZGVmZXJyZWQgPSBbXTtcbl9fd2VicGFja19yZXF1aXJlX18uTyA9IChyZXN1bHQsIGNodW5rSWRzLCBmbiwgcHJpb3JpdHkpID0+IHtcblx0aWYoY2h1bmtJZHMpIHtcblx0XHRwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0Zm9yKHZhciBpID0gZGVmZXJyZWQubGVuZ3RoOyBpID4gMCAmJiBkZWZlcnJlZFtpIC0gMV1bMl0gPiBwcmlvcml0eTsgaS0tKSBkZWZlcnJlZFtpXSA9IGRlZmVycmVkW2kgLSAxXTtcblx0XHRkZWZlcnJlZFtpXSA9IFtjaHVua0lkcywgZm4sIHByaW9yaXR5XTtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIG5vdEZ1bGZpbGxlZCA9IEluZmluaXR5O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIFtjaHVua0lkcywgZm4sIHByaW9yaXR5XSA9IGRlZmVycmVkW2ldO1xuXHRcdHZhciBmdWxmaWxsZWQgPSB0cnVlO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgY2h1bmtJZHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmICgocHJpb3JpdHkgJiAxID09PSAwIHx8IG5vdEZ1bGZpbGxlZCA+PSBwcmlvcml0eSkgJiYgT2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5PKS5ldmVyeSgoa2V5KSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXy5PW2tleV0oY2h1bmtJZHNbal0pKSkpIHtcblx0XHRcdFx0Y2h1bmtJZHMuc3BsaWNlKGotLSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmdWxmaWxsZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYocHJpb3JpdHkgPCBub3RGdWxmaWxsZWQpIG5vdEZ1bGZpbGxlZCA9IHByaW9yaXR5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihmdWxmaWxsZWQpIHtcblx0XHRcdGRlZmVycmVkLnNwbGljZShpLS0sIDEpXG5cdFx0XHR2YXIgciA9IGZuKCk7XG5cdFx0XHRpZiAociAhPT0gdW5kZWZpbmVkKSByZXN1bHQgPSByO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTsiLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaSA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcblx0XHRcdHdoaWxlIChpID4gLTEgJiYgKCFzY3JpcHRVcmwgfHwgIS9eaHR0cChzPyk6Ly50ZXN0KHNjcmlwdFVybCkpKSBzY3JpcHRVcmwgPSBzY3JpcHRzW2ktLV0uc3JjO1xuXHRcdH1cblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwiaW5kZXhcIjogMCxcblx0XCJzdHlsZXNcIjogMFxufTtcblxuLy8gbm8gY2h1bmsgb24gZGVtYW5kIGxvYWRpbmdcblxuLy8gbm8gcHJlZmV0Y2hpbmdcblxuLy8gbm8gcHJlbG9hZGVkXG5cbi8vIG5vIEhNUlxuXG4vLyBubyBITVIgbWFuaWZlc3RcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5PLmogPSAoY2h1bmtJZCkgPT4gKGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9PT0gMCk7XG5cbi8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xudmFyIHdlYnBhY2tKc29ucENhbGxiYWNrID0gKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uLCBkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMDtcblx0aWYoY2h1bmtJZHMuc29tZSgoaWQpID0+IChpbnN0YWxsZWRDaHVua3NbaWRdICE9PSAwKSkpIHtcblx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHJ1bnRpbWUpIHZhciByZXN1bHQgPSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR9XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0oKTtcblx0XHR9XG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0fVxuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHJlc3VsdCk7XG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rdGVtcGxhdGVcIl0gPSBzZWxmW1wid2VicGFja0NodW5rdGVtcGxhdGVcIl0gfHwgW107XG5jaHVua0xvYWRpbmdHbG9iYWwuZm9yRWFjaCh3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIDApKTtcbmNodW5rTG9hZGluZ0dsb2JhbC5wdXNoID0gd2VicGFja0pzb25wQ2FsbGJhY2suYmluZChudWxsLCBjaHVua0xvYWRpbmdHbG9iYWwucHVzaC5iaW5kKGNodW5rTG9hZGluZ0dsb2JhbCkpOyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgZGVwZW5kcyBvbiBvdGhlciBsb2FkZWQgY2h1bmtzIGFuZCBleGVjdXRpb24gbmVlZCB0byBiZSBkZWxheWVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18uTyh1bmRlZmluZWQsIFtcInN0eWxlc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC5qc1wiKSkpXG5fX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXy5PKF9fd2VicGFja19leHBvcnRzX18pO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9